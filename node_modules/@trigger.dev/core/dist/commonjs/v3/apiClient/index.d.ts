import { z } from "zod";
import { AddTagsRequestBody, BatchTaskRunExecutionResult, BatchTriggerTaskV3RequestBody, CompleteWaitpointTokenRequestBody, CreateEnvironmentVariableRequestBody, CreateScheduleOptions, CreateWaitpointTokenRequestBody, CreateWaitpointTokenResponseBody, ListQueueOptions, ListRunResponseItem, ListScheduleOptions, RescheduleRunRequestBody, RetrieveQueueParam, TaskRunExecutionResult, TriggerTaskRequestBody, UpdateEnvironmentVariableRequestBody, UpdateMetadataRequestBody, UpdateScheduleOptions, WaitForDurationRequestBody, WaitpointTokenItem } from "../schemas/index.js";
import { AsyncIterableStream } from "../streams/asyncIterableStream.js";
import { AnyRunTypes, TriggerJwtOptions } from "../types/tasks.js";
import { Prettify } from "../types/utils.js";
import { AnyZodFetchOptions, ApiPromise, ApiRequestOptions, CursorPagePromise, ZodFetchOptions, isRequestOptions } from "./core.js";
import { AnyRealtimeRun, AnyRunShape, RealtimeRun, RunShape, RunStreamCallback, RunSubscription, TaskRunShape, RealtimeRunSkipColumns } from "./runStream.js";
import { CreateEnvironmentVariableParams, ImportEnvironmentVariablesParams, ListProjectRunsQueryParams, ListRunsQueryParams, ListWaitpointTokensQueryParams, SubscribeToRunsQueryParams, UpdateEnvironmentVariableParams } from "./types.js";
export type CreateWaitpointTokenResponse = Prettify<CreateWaitpointTokenResponseBody & {
    publicAccessToken: string;
}>;
export type { CreateEnvironmentVariableParams, ImportEnvironmentVariablesParams, SubscribeToRunsQueryParams, UpdateEnvironmentVariableParams, RealtimeRunSkipColumns, };
export type ClientTriggerOptions = {
    spanParentAsLink?: boolean;
};
export type ClientBatchTriggerOptions = ClientTriggerOptions & {
    processingStrategy?: "parallel" | "sequential";
};
export type TriggerRequestOptions = ZodFetchOptions & {
    publicAccessToken?: TriggerJwtOptions;
};
export type TriggerApiRequestOptions = ApiRequestOptions & {
    publicAccessToken?: TriggerJwtOptions;
};
export { isRequestOptions };
export type { AnyRealtimeRun, AnyRunShape, ApiRequestOptions, RealtimeRun, RunShape, RunStreamCallback, RunSubscription, TaskRunShape, };
export * from "./getBranch.js";
/**
 * Trigger.dev v3 API client
 */
export declare class ApiClient {
    #private;
    readonly baseUrl: string;
    readonly accessToken: string;
    readonly previewBranch?: string;
    private readonly defaultRequestOptions;
    constructor(baseUrl: string, accessToken: string, previewBranch?: string, requestOptions?: ApiRequestOptions);
    get fetchClient(): typeof fetch;
    getHeaders(): Record<string, string>;
    getRunResult(runId: string, requestOptions?: ZodFetchOptions): Promise<TaskRunExecutionResult | undefined>;
    getBatchResults(batchId: string, requestOptions?: ZodFetchOptions): Promise<BatchTaskRunExecutionResult | undefined>;
    triggerTask(taskId: string, body: TriggerTaskRequestBody, clientOptions?: ClientTriggerOptions, requestOptions?: TriggerRequestOptions): Promise<{
        publicAccessToken: string;
        id: string;
        isCached?: boolean | undefined;
    }>;
    batchTriggerV3(body: BatchTriggerTaskV3RequestBody, clientOptions?: ClientBatchTriggerOptions, requestOptions?: TriggerRequestOptions): Promise<{
        publicAccessToken: string;
        id: string;
        runCount: number;
    }>;
    createUploadPayloadUrl(filename: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        presignedUrl: string;
    }>;
    getPayloadUrl(filename: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        presignedUrl: string;
    }>;
    retrieveRun(runId: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        status: "PENDING_VERSION" | "QUEUED" | "DEQUEUED" | "EXECUTING" | "WAITING" | "COMPLETED" | "CANCELED" | "FAILED" | "CRASHED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED" | "TIMED_OUT";
        id: string;
        tags: string[];
        isTest: boolean;
        createdAt: Date;
        baseCostInCents: number;
        durationMs: number;
        costInCents: number;
        taskIdentifier: string;
        relatedRuns: {
            root?: {
                status: "PENDING_VERSION" | "QUEUED" | "DEQUEUED" | "EXECUTING" | "WAITING" | "COMPLETED" | "CANCELED" | "FAILED" | "CRASHED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED" | "TIMED_OUT";
                id: string;
                tags: string[];
                isTest: boolean;
                createdAt: Date;
                baseCostInCents: number;
                durationMs: number;
                costInCents: number;
                taskIdentifier: string;
                depth: number;
                triggerFunction: "trigger" | "batchTrigger" | "triggerAndWait" | "batchTriggerAndWait";
                isQueued: boolean;
                isExecuting: boolean;
                isWaiting: boolean;
                isCompleted: boolean;
                isSuccess: boolean;
                isFailed: boolean;
                isCancelled: boolean;
                updatedAt: Date;
                metadata?: Record<string, any> | undefined;
                startedAt?: Date | undefined;
                idempotencyKey?: string | undefined;
                version?: string | undefined;
                ttl?: string | undefined;
                batchId?: string | undefined;
                finishedAt?: Date | undefined;
                delayedUntil?: Date | undefined;
                expiredAt?: Date | undefined;
            } | undefined;
            parent?: {
                status: "PENDING_VERSION" | "QUEUED" | "DEQUEUED" | "EXECUTING" | "WAITING" | "COMPLETED" | "CANCELED" | "FAILED" | "CRASHED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED" | "TIMED_OUT";
                id: string;
                tags: string[];
                isTest: boolean;
                createdAt: Date;
                baseCostInCents: number;
                durationMs: number;
                costInCents: number;
                taskIdentifier: string;
                depth: number;
                triggerFunction: "trigger" | "batchTrigger" | "triggerAndWait" | "batchTriggerAndWait";
                isQueued: boolean;
                isExecuting: boolean;
                isWaiting: boolean;
                isCompleted: boolean;
                isSuccess: boolean;
                isFailed: boolean;
                isCancelled: boolean;
                updatedAt: Date;
                metadata?: Record<string, any> | undefined;
                startedAt?: Date | undefined;
                idempotencyKey?: string | undefined;
                version?: string | undefined;
                ttl?: string | undefined;
                batchId?: string | undefined;
                finishedAt?: Date | undefined;
                delayedUntil?: Date | undefined;
                expiredAt?: Date | undefined;
            } | undefined;
            children?: {
                status: "PENDING_VERSION" | "QUEUED" | "DEQUEUED" | "EXECUTING" | "WAITING" | "COMPLETED" | "CANCELED" | "FAILED" | "CRASHED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED" | "TIMED_OUT";
                id: string;
                tags: string[];
                isTest: boolean;
                createdAt: Date;
                baseCostInCents: number;
                durationMs: number;
                costInCents: number;
                taskIdentifier: string;
                depth: number;
                triggerFunction: "trigger" | "batchTrigger" | "triggerAndWait" | "batchTriggerAndWait";
                isQueued: boolean;
                isExecuting: boolean;
                isWaiting: boolean;
                isCompleted: boolean;
                isSuccess: boolean;
                isFailed: boolean;
                isCancelled: boolean;
                updatedAt: Date;
                metadata?: Record<string, any> | undefined;
                startedAt?: Date | undefined;
                idempotencyKey?: string | undefined;
                version?: string | undefined;
                ttl?: string | undefined;
                batchId?: string | undefined;
                finishedAt?: Date | undefined;
                delayedUntil?: Date | undefined;
                expiredAt?: Date | undefined;
            }[] | undefined;
        };
        depth: number;
        triggerFunction: "trigger" | "batchTrigger" | "triggerAndWait" | "batchTriggerAndWait";
        isQueued: boolean;
        isExecuting: boolean;
        isWaiting: boolean;
        isCompleted: boolean;
        isSuccess: boolean;
        isFailed: boolean;
        isCancelled: boolean;
        updatedAt: Date;
        attemptCount: number;
        payload?: any;
        error?: {
            message: string;
            name?: string | undefined;
            stackTrace?: string | undefined;
        } | undefined;
        metadata?: Record<string, any> | undefined;
        startedAt?: Date | undefined;
        idempotencyKey?: string | undefined;
        version?: string | undefined;
        output?: any;
        ttl?: string | undefined;
        schedule?: {
            id: string;
            generator: {
                type: "CRON";
                description: string;
                expression: string;
            };
            externalId?: string | undefined;
            deduplicationKey?: string | undefined;
        } | undefined;
        payloadPresignedUrl?: string | undefined;
        outputPresignedUrl?: string | undefined;
        batchId?: string | undefined;
        finishedAt?: Date | undefined;
        delayedUntil?: Date | undefined;
        expiredAt?: Date | undefined;
    }>;
    listRuns(query?: ListRunsQueryParams, requestOptions?: ZodFetchOptions): CursorPagePromise<typeof ListRunResponseItem>;
    listProjectRuns(projectRef: string, query?: ListProjectRunsQueryParams, requestOptions?: ZodFetchOptions): CursorPagePromise<typeof ListRunResponseItem>;
    replayRun(runId: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        id: string;
    }>;
    cancelRun(runId: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        id: string;
    }>;
    rescheduleRun(runId: string, body: RescheduleRunRequestBody, requestOptions?: ZodFetchOptions): ApiPromise<{
        status: "PENDING_VERSION" | "QUEUED" | "DEQUEUED" | "EXECUTING" | "WAITING" | "COMPLETED" | "CANCELED" | "FAILED" | "CRASHED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED" | "TIMED_OUT";
        id: string;
        tags: string[];
        isTest: boolean;
        createdAt: Date;
        baseCostInCents: number;
        durationMs: number;
        costInCents: number;
        taskIdentifier: string;
        relatedRuns: {
            root?: {
                status: "PENDING_VERSION" | "QUEUED" | "DEQUEUED" | "EXECUTING" | "WAITING" | "COMPLETED" | "CANCELED" | "FAILED" | "CRASHED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED" | "TIMED_OUT";
                id: string;
                tags: string[];
                isTest: boolean;
                createdAt: Date;
                baseCostInCents: number;
                durationMs: number;
                costInCents: number;
                taskIdentifier: string;
                depth: number;
                triggerFunction: "trigger" | "batchTrigger" | "triggerAndWait" | "batchTriggerAndWait";
                isQueued: boolean;
                isExecuting: boolean;
                isWaiting: boolean;
                isCompleted: boolean;
                isSuccess: boolean;
                isFailed: boolean;
                isCancelled: boolean;
                updatedAt: Date;
                metadata?: Record<string, any> | undefined;
                startedAt?: Date | undefined;
                idempotencyKey?: string | undefined;
                version?: string | undefined;
                ttl?: string | undefined;
                batchId?: string | undefined;
                finishedAt?: Date | undefined;
                delayedUntil?: Date | undefined;
                expiredAt?: Date | undefined;
            } | undefined;
            parent?: {
                status: "PENDING_VERSION" | "QUEUED" | "DEQUEUED" | "EXECUTING" | "WAITING" | "COMPLETED" | "CANCELED" | "FAILED" | "CRASHED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED" | "TIMED_OUT";
                id: string;
                tags: string[];
                isTest: boolean;
                createdAt: Date;
                baseCostInCents: number;
                durationMs: number;
                costInCents: number;
                taskIdentifier: string;
                depth: number;
                triggerFunction: "trigger" | "batchTrigger" | "triggerAndWait" | "batchTriggerAndWait";
                isQueued: boolean;
                isExecuting: boolean;
                isWaiting: boolean;
                isCompleted: boolean;
                isSuccess: boolean;
                isFailed: boolean;
                isCancelled: boolean;
                updatedAt: Date;
                metadata?: Record<string, any> | undefined;
                startedAt?: Date | undefined;
                idempotencyKey?: string | undefined;
                version?: string | undefined;
                ttl?: string | undefined;
                batchId?: string | undefined;
                finishedAt?: Date | undefined;
                delayedUntil?: Date | undefined;
                expiredAt?: Date | undefined;
            } | undefined;
            children?: {
                status: "PENDING_VERSION" | "QUEUED" | "DEQUEUED" | "EXECUTING" | "WAITING" | "COMPLETED" | "CANCELED" | "FAILED" | "CRASHED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED" | "TIMED_OUT";
                id: string;
                tags: string[];
                isTest: boolean;
                createdAt: Date;
                baseCostInCents: number;
                durationMs: number;
                costInCents: number;
                taskIdentifier: string;
                depth: number;
                triggerFunction: "trigger" | "batchTrigger" | "triggerAndWait" | "batchTriggerAndWait";
                isQueued: boolean;
                isExecuting: boolean;
                isWaiting: boolean;
                isCompleted: boolean;
                isSuccess: boolean;
                isFailed: boolean;
                isCancelled: boolean;
                updatedAt: Date;
                metadata?: Record<string, any> | undefined;
                startedAt?: Date | undefined;
                idempotencyKey?: string | undefined;
                version?: string | undefined;
                ttl?: string | undefined;
                batchId?: string | undefined;
                finishedAt?: Date | undefined;
                delayedUntil?: Date | undefined;
                expiredAt?: Date | undefined;
            }[] | undefined;
        };
        depth: number;
        triggerFunction: "trigger" | "batchTrigger" | "triggerAndWait" | "batchTriggerAndWait";
        isQueued: boolean;
        isExecuting: boolean;
        isWaiting: boolean;
        isCompleted: boolean;
        isSuccess: boolean;
        isFailed: boolean;
        isCancelled: boolean;
        updatedAt: Date;
        attemptCount: number;
        payload?: any;
        error?: {
            message: string;
            name?: string | undefined;
            stackTrace?: string | undefined;
        } | undefined;
        metadata?: Record<string, any> | undefined;
        startedAt?: Date | undefined;
        idempotencyKey?: string | undefined;
        version?: string | undefined;
        output?: any;
        ttl?: string | undefined;
        schedule?: {
            id: string;
            generator: {
                type: "CRON";
                description: string;
                expression: string;
            };
            externalId?: string | undefined;
            deduplicationKey?: string | undefined;
        } | undefined;
        payloadPresignedUrl?: string | undefined;
        outputPresignedUrl?: string | undefined;
        batchId?: string | undefined;
        finishedAt?: Date | undefined;
        delayedUntil?: Date | undefined;
        expiredAt?: Date | undefined;
    }>;
    listRunEvents(runId: string, requestOptions?: ZodFetchOptions): ApiPromise<any>;
    addTags(runId: string, body: AddTagsRequestBody, requestOptions?: ZodFetchOptions): ApiPromise<{
        message: string;
    }>;
    createSchedule(options: CreateScheduleOptions, requestOptions?: ZodFetchOptions): ApiPromise<{
        type: "DECLARATIVE" | "IMPERATIVE";
        id: string;
        task: string;
        timezone: string;
        environments: {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }[];
        generator: {
            type: "CRON";
            description: string;
            expression: string;
        };
        active: boolean;
        externalId?: string | null | undefined;
        deduplicationKey?: string | null | undefined;
        nextRun?: Date | null | undefined;
    }>;
    listSchedules(options?: ListScheduleOptions, requestOptions?: ZodFetchOptions): import("./core.js").OffsetLimitPagePromise<z.ZodObject<{
        id: z.ZodString;
        type: z.ZodUnion<[z.ZodLiteral<"DECLARATIVE">, z.ZodLiteral<"IMPERATIVE">]>;
        task: z.ZodString;
        active: z.ZodBoolean;
        deduplicationKey: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        externalId: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        generator: z.ZodObject<{
            type: z.ZodLiteral<"CRON">;
            expression: z.ZodString;
            description: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            type: "CRON";
            description: string;
            expression: string;
        }, {
            type: "CRON";
            description: string;
            expression: string;
        }>;
        timezone: z.ZodString;
        nextRun: z.ZodOptional<z.ZodNullable<z.ZodDate>>;
        environments: z.ZodArray<z.ZodObject<{
            id: z.ZodString;
            type: z.ZodString;
            userName: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        }, "strip", z.ZodTypeAny, {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }, {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }>, "many">;
    }, "strip", z.ZodTypeAny, {
        type: "DECLARATIVE" | "IMPERATIVE";
        id: string;
        task: string;
        timezone: string;
        environments: {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }[];
        generator: {
            type: "CRON";
            description: string;
            expression: string;
        };
        active: boolean;
        externalId?: string | null | undefined;
        deduplicationKey?: string | null | undefined;
        nextRun?: Date | null | undefined;
    }, {
        type: "DECLARATIVE" | "IMPERATIVE";
        id: string;
        task: string;
        timezone: string;
        environments: {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }[];
        generator: {
            type: "CRON";
            description: string;
            expression: string;
        };
        active: boolean;
        externalId?: string | null | undefined;
        deduplicationKey?: string | null | undefined;
        nextRun?: Date | null | undefined;
    }>>;
    retrieveSchedule(scheduleId: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        type: "DECLARATIVE" | "IMPERATIVE";
        id: string;
        task: string;
        timezone: string;
        environments: {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }[];
        generator: {
            type: "CRON";
            description: string;
            expression: string;
        };
        active: boolean;
        externalId?: string | null | undefined;
        deduplicationKey?: string | null | undefined;
        nextRun?: Date | null | undefined;
    }>;
    updateSchedule(scheduleId: string, options: UpdateScheduleOptions, requestOptions?: ZodFetchOptions): ApiPromise<{
        type: "DECLARATIVE" | "IMPERATIVE";
        id: string;
        task: string;
        timezone: string;
        environments: {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }[];
        generator: {
            type: "CRON";
            description: string;
            expression: string;
        };
        active: boolean;
        externalId?: string | null | undefined;
        deduplicationKey?: string | null | undefined;
        nextRun?: Date | null | undefined;
    }>;
    deactivateSchedule(scheduleId: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        type: "DECLARATIVE" | "IMPERATIVE";
        id: string;
        task: string;
        timezone: string;
        environments: {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }[];
        generator: {
            type: "CRON";
            description: string;
            expression: string;
        };
        active: boolean;
        externalId?: string | null | undefined;
        deduplicationKey?: string | null | undefined;
        nextRun?: Date | null | undefined;
    }>;
    activateSchedule(scheduleId: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        type: "DECLARATIVE" | "IMPERATIVE";
        id: string;
        task: string;
        timezone: string;
        environments: {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }[];
        generator: {
            type: "CRON";
            description: string;
            expression: string;
        };
        active: boolean;
        externalId?: string | null | undefined;
        deduplicationKey?: string | null | undefined;
        nextRun?: Date | null | undefined;
    }>;
    deleteSchedule(scheduleId: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        id: string;
    }>;
    listEnvVars(projectRef: string, slug: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        value: string;
        name: string;
        isSecret: boolean;
    }[]>;
    importEnvVars(projectRef: string, slug: string, body: ImportEnvironmentVariablesParams, requestOptions?: ZodFetchOptions): ApiPromise<{
        success: boolean;
    }>;
    retrieveEnvVar(projectRef: string, slug: string, key: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        value: string;
        name: string;
        isSecret: boolean;
    }>;
    createEnvVar(projectRef: string, slug: string, body: CreateEnvironmentVariableRequestBody, requestOptions?: ZodFetchOptions): ApiPromise<{
        success: boolean;
    }>;
    updateEnvVar(projectRef: string, slug: string, key: string, body: UpdateEnvironmentVariableRequestBody, requestOptions?: ZodFetchOptions): ApiPromise<{
        success: boolean;
    }>;
    deleteEnvVar(projectRef: string, slug: string, key: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        success: boolean;
    }>;
    updateRunMetadata(runId: string, body: UpdateMetadataRequestBody, requestOptions?: ZodFetchOptions): ApiPromise<{
        metadata: Record<string, import("../../index.js").DeserializedJson>;
    }>;
    getRunMetadata(runId: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        metadata: Record<string, import("../../index.js").DeserializedJson>;
    }>;
    createWaitpointToken(options: CreateWaitpointTokenRequestBody, requestOptions?: ZodFetchOptions): ApiPromise<CreateWaitpointTokenResponse>;
    listWaitpointTokens(params?: ListWaitpointTokensQueryParams, requestOptions?: ZodFetchOptions): CursorPagePromise<typeof WaitpointTokenItem>;
    retrieveWaitpointToken(friendlyId: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        status: "WAITING" | "COMPLETED" | "TIMED_OUT";
        url: string;
        id: string;
        tags: string[];
        createdAt: Date;
        idempotencyKey?: string | undefined;
        completedAt?: Date | undefined;
        timeoutAt?: Date | undefined;
        idempotencyKeyExpiresAt?: Date | undefined;
    } & {
        output?: string | undefined;
        outputType?: string | undefined;
        outputIsError?: boolean | undefined;
    }>;
    completeWaitpointToken(friendlyId: string, options: CompleteWaitpointTokenRequestBody, requestOptions?: ZodFetchOptions): ApiPromise<{
        success: true;
    }>;
    waitForWaitpointToken({ runFriendlyId, waitpointFriendlyId, }: {
        runFriendlyId: string;
        waitpointFriendlyId: string;
    }, requestOptions?: ZodFetchOptions): ApiPromise<{
        success: boolean;
    }>;
    waitForDuration(runId: string, body: WaitForDurationRequestBody, requestOptions?: ZodFetchOptions): Promise<{
        waitUntil: Date;
        waitpoint: {
            id: string;
        };
    }>;
    listQueues(options?: ListQueueOptions, requestOptions?: ZodFetchOptions): import("./core.js").OffsetLimitPagePromise<z.ZodObject<{
        id: z.ZodString;
        name: z.ZodString;
        type: z.ZodEnum<["task", "custom"]>;
        running: z.ZodNumber;
        queued: z.ZodNumber;
        concurrencyLimit: z.ZodNullable<z.ZodNumber>;
        paused: z.ZodBoolean;
    }, "strip", z.ZodTypeAny, {
        type: "custom" | "task";
        name: string;
        id: string;
        concurrencyLimit: number | null;
        running: number;
        queued: number;
        paused: boolean;
    }, {
        type: "custom" | "task";
        name: string;
        id: string;
        concurrencyLimit: number | null;
        running: number;
        queued: number;
        paused: boolean;
    }>>;
    retrieveQueue(queue: RetrieveQueueParam, requestOptions?: ZodFetchOptions): ApiPromise<{
        type: "custom" | "task";
        name: string;
        id: string;
        concurrencyLimit: number | null;
        running: number;
        queued: number;
        paused: boolean;
    }>;
    pauseQueue(queue: RetrieveQueueParam, action: "pause" | "resume", requestOptions?: ZodFetchOptions): ApiPromise<{
        type: "custom" | "task";
        name: string;
        id: string;
        concurrencyLimit: number | null;
        running: number;
        queued: number;
        paused: boolean;
    }>;
    subscribeToRun<TRunTypes extends AnyRunTypes>(runId: string, options?: {
        signal?: AbortSignal;
        closeOnComplete?: boolean;
        onFetchError?: (error: Error) => void;
        skipColumns?: string[];
    }): RunSubscription<TRunTypes>;
    subscribeToRunsWithTag<TRunTypes extends AnyRunTypes>(tag: string | string[], filters?: {
        createdAt?: string;
        skipColumns?: string[];
    }, options?: {
        signal?: AbortSignal;
        onFetchError?: (error: Error) => void;
    }): RunSubscription<TRunTypes>;
    subscribeToBatch<TRunTypes extends AnyRunTypes>(batchId: string, options?: {
        signal?: AbortSignal;
        onFetchError?: (error: Error) => void;
        skipColumns?: string[];
    }): RunSubscription<TRunTypes>;
    fetchStream<T>(runId: string, streamKey: string, options?: {
        signal?: AbortSignal;
        baseUrl?: string;
    }): Promise<AsyncIterableStream<T>>;
    generateJWTClaims(requestOptions?: ZodFetchOptions): Promise<Record<string, any>>;
    retrieveBatch(batchId: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        status: "COMPLETED" | "PENDING";
        id: string;
        createdAt: Date;
        updatedAt: Date;
        runs: string[];
        runCount: number;
        idempotencyKey?: string | undefined;
    }>;
}
export declare function mergeRequestOptions(defaultOptions: AnyZodFetchOptions, options?: ApiRequestOptions): AnyZodFetchOptions;
