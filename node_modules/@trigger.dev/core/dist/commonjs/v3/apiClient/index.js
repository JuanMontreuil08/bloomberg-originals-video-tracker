"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiClient = exports.isRequestOptions = void 0;
exports.mergeRequestOptions = mergeRequestOptions;
const zod_1 = require("zod");
const version_js_1 = require("../../version.js");
const jwt_js_1 = require("../jwt.js");
const index_js_1 = require("../schemas/index.js");
const task_context_api_js_1 = require("../task-context-api.js");
const core_js_1 = require("./core.js");
Object.defineProperty(exports, "isRequestOptions", { enumerable: true, get: function () { return core_js_1.isRequestOptions; } });
const errors_js_1 = require("./errors.js");
const runStream_js_1 = require("./runStream.js");
const version_js_2 = require("./version.js");
const DEFAULT_ZOD_FETCH_OPTIONS = {
    retry: {
        maxAttempts: 5,
        minTimeoutInMs: 1000,
        maxTimeoutInMs: 30_000,
        factor: 1.6,
        randomize: false,
    },
};
__exportStar(require("./getBranch.js"), exports);
/**
 * Trigger.dev v3 API client
 */
class ApiClient {
    baseUrl;
    accessToken;
    previewBranch;
    defaultRequestOptions;
    constructor(baseUrl, accessToken, previewBranch, requestOptions = {}) {
        this.accessToken = accessToken;
        this.baseUrl = baseUrl.replace(/\/$/, "");
        this.previewBranch = previewBranch;
        this.defaultRequestOptions = mergeRequestOptions(DEFAULT_ZOD_FETCH_OPTIONS, requestOptions);
    }
    get fetchClient() {
        const headers = this.#getHeaders(false);
        const fetchClient = (input, requestInit) => {
            const $requestInit = {
                ...requestInit,
                headers: {
                    ...requestInit?.headers,
                    ...headers,
                },
            };
            return fetch(input, $requestInit);
        };
        return fetchClient;
    }
    getHeaders() {
        return this.#getHeaders(false);
    }
    async getRunResult(runId, requestOptions) {
        try {
            return await (0, core_js_1.zodfetch)(index_js_1.TaskRunExecutionResult, `${this.baseUrl}/api/v1/runs/${runId}/result`, {
                method: "GET",
                headers: this.#getHeaders(false),
            }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
        }
        catch (error) {
            if (error instanceof errors_js_1.ApiError) {
                if (error.status === 404) {
                    return undefined;
                }
            }
            throw error;
        }
    }
    async getBatchResults(batchId, requestOptions) {
        return await (0, core_js_1.zodfetch)(index_js_1.BatchTaskRunExecutionResult, `${this.baseUrl}/api/v1/batches/${batchId}/results`, {
            method: "GET",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    triggerTask(taskId, body, clientOptions, requestOptions) {
        const encodedTaskId = encodeURIComponent(taskId);
        return (0, core_js_1.zodfetch)(index_js_1.TriggerTaskResponse, `${this.baseUrl}/api/v1/tasks/${encodedTaskId}/trigger`, {
            method: "POST",
            headers: this.#getHeaders(clientOptions?.spanParentAsLink ?? false),
            body: JSON.stringify(body),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions))
            .withResponse()
            .then(async ({ data, response }) => {
            const jwtHeader = response.headers.get("x-trigger-jwt");
            if (typeof jwtHeader === "string") {
                return {
                    ...data,
                    publicAccessToken: jwtHeader,
                };
            }
            const claimsHeader = response.headers.get("x-trigger-jwt-claims");
            const claims = claimsHeader ? JSON.parse(claimsHeader) : undefined;
            const jwt = await (0, jwt_js_1.generateJWT)({
                secretKey: this.accessToken,
                payload: {
                    ...claims,
                    scopes: [`read:runs:${data.id}`],
                },
                expirationTime: requestOptions?.publicAccessToken?.expirationTime ?? "1h",
            });
            return {
                ...data,
                publicAccessToken: jwt,
            };
        });
    }
    batchTriggerV3(body, clientOptions, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.BatchTriggerTaskV3Response, `${this.baseUrl}/api/v2/tasks/batch`, {
            method: "POST",
            headers: this.#getHeaders(clientOptions?.spanParentAsLink ?? false, {
                "batch-processing-strategy": clientOptions?.processingStrategy,
            }),
            body: JSON.stringify(body),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions))
            .withResponse()
            .then(async ({ data, response }) => {
            const claimsHeader = response.headers.get("x-trigger-jwt-claims");
            const claims = claimsHeader ? JSON.parse(claimsHeader) : undefined;
            const jwt = await (0, jwt_js_1.generateJWT)({
                secretKey: this.accessToken,
                payload: {
                    ...claims,
                    scopes: [`read:batch:${data.id}`],
                },
                expirationTime: requestOptions?.publicAccessToken?.expirationTime ?? "1h",
            });
            return {
                ...data,
                publicAccessToken: jwt,
            };
        });
    }
    createUploadPayloadUrl(filename, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.CreateUploadPayloadUrlResponseBody, `${this.baseUrl}/api/v1/packets/${filename}`, {
            method: "PUT",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    getPayloadUrl(filename, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.CreateUploadPayloadUrlResponseBody, `${this.baseUrl}/api/v1/packets/${filename}`, {
            method: "GET",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    retrieveRun(runId, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.RetrieveRunResponse, `${this.baseUrl}/api/v3/runs/${runId}`, {
            method: "GET",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    listRuns(query, requestOptions) {
        const searchParams = createSearchQueryForListRuns(query);
        return (0, core_js_1.zodfetchCursorPage)(index_js_1.ListRunResponseItem, `${this.baseUrl}/api/v1/runs`, {
            query: searchParams,
            limit: query?.limit,
            after: query?.after,
            before: query?.before,
        }, {
            method: "GET",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    listProjectRuns(projectRef, query, requestOptions) {
        const searchParams = createSearchQueryForListRuns(query);
        if (query?.env) {
            searchParams.append("filter[env]", Array.isArray(query.env) ? query.env.join(",") : query.env);
        }
        return (0, core_js_1.zodfetchCursorPage)(index_js_1.ListRunResponseItem, `${this.baseUrl}/api/v1/projects/${projectRef}/runs`, {
            query: searchParams,
            limit: query?.limit,
            after: query?.after,
            before: query?.before,
        }, {
            method: "GET",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    replayRun(runId, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.ReplayRunResponse, `${this.baseUrl}/api/v1/runs/${runId}/replay`, {
            method: "POST",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    cancelRun(runId, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.CanceledRunResponse, `${this.baseUrl}/api/v2/runs/${runId}/cancel`, {
            method: "POST",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    rescheduleRun(runId, body, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.RetrieveRunResponse, `${this.baseUrl}/api/v1/runs/${runId}/reschedule`, {
            method: "POST",
            headers: this.#getHeaders(false),
            body: JSON.stringify(body),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    listRunEvents(runId, requestOptions) {
        return (0, core_js_1.zodfetch)(zod_1.z.any(), // TODO: define a proper schema for this
        `${this.baseUrl}/api/v1/runs/${runId}/events`, {
            method: "GET",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    addTags(runId, body, requestOptions) {
        return (0, core_js_1.zodfetch)(zod_1.z.object({ message: zod_1.z.string() }), `${this.baseUrl}/api/v1/runs/${runId}/tags`, {
            method: "POST",
            headers: this.#getHeaders(false),
            body: JSON.stringify(body),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    createSchedule(options, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.ScheduleObject, `${this.baseUrl}/api/v1/schedules`, {
            method: "POST",
            headers: this.#getHeaders(false),
            body: JSON.stringify(options),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    listSchedules(options, requestOptions) {
        const searchParams = new URLSearchParams();
        if (options?.page) {
            searchParams.append("page", options.page.toString());
        }
        if (options?.perPage) {
            searchParams.append("perPage", options.perPage.toString());
        }
        return (0, core_js_1.zodfetchOffsetLimitPage)(index_js_1.ScheduleObject, `${this.baseUrl}/api/v1/schedules`, {
            page: options?.page,
            limit: options?.perPage,
        }, {
            method: "GET",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    retrieveSchedule(scheduleId, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.ScheduleObject, `${this.baseUrl}/api/v1/schedules/${scheduleId}`, {
            method: "GET",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    updateSchedule(scheduleId, options, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.ScheduleObject, `${this.baseUrl}/api/v1/schedules/${scheduleId}`, {
            method: "PUT",
            headers: this.#getHeaders(false),
            body: JSON.stringify(options),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    deactivateSchedule(scheduleId, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.ScheduleObject, `${this.baseUrl}/api/v1/schedules/${scheduleId}/deactivate`, {
            method: "POST",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    activateSchedule(scheduleId, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.ScheduleObject, `${this.baseUrl}/api/v1/schedules/${scheduleId}/activate`, {
            method: "POST",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    deleteSchedule(scheduleId, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.DeletedScheduleObject, `${this.baseUrl}/api/v1/schedules/${scheduleId}`, {
            method: "DELETE",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    listEnvVars(projectRef, slug, requestOptions) {
        return (0, core_js_1.zodfetch)(zod_1.z.array(index_js_1.EnvironmentVariableWithSecret), `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}`, {
            method: "GET",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    importEnvVars(projectRef, slug, body, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.EnvironmentVariableResponseBody, `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/import`, {
            method: "POST",
            headers: this.#getHeaders(false),
            body: JSON.stringify(body),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    retrieveEnvVar(projectRef, slug, key, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.EnvironmentVariableWithSecret, `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/${key}`, {
            method: "GET",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    createEnvVar(projectRef, slug, body, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.EnvironmentVariableResponseBody, `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}`, {
            method: "POST",
            headers: this.#getHeaders(false),
            body: JSON.stringify(body),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    updateEnvVar(projectRef, slug, key, body, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.EnvironmentVariableResponseBody, `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/${key}`, {
            method: "PUT",
            headers: this.#getHeaders(false),
            body: JSON.stringify(body),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    deleteEnvVar(projectRef, slug, key, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.EnvironmentVariableResponseBody, `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/${key}`, {
            method: "DELETE",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    updateRunMetadata(runId, body, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.UpdateMetadataResponseBody, `${this.baseUrl}/api/v1/runs/${runId}/metadata`, {
            method: "PUT",
            headers: this.#getHeaders(false),
            body: JSON.stringify(body),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    getRunMetadata(runId, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.UpdateMetadataResponseBody, `${this.baseUrl}/api/v1/runs/${runId}/metadata`, {
            method: "GET",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    createWaitpointToken(options, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.CreateWaitpointTokenResponseBody, `${this.baseUrl}/api/v1/waitpoints/tokens`, {
            method: "POST",
            headers: this.#getHeaders(false),
            body: JSON.stringify(options),
        }, {
            ...mergeRequestOptions(this.defaultRequestOptions, requestOptions),
            prepareData: async (data, response) => {
                const jwtHeader = response.headers.get("x-trigger-jwt");
                if (typeof jwtHeader === "string") {
                    return {
                        ...data,
                        publicAccessToken: jwtHeader,
                    };
                }
                const claimsHeader = response.headers.get("x-trigger-jwt-claims");
                const claims = claimsHeader ? JSON.parse(claimsHeader) : undefined;
                const jwt = await (0, jwt_js_1.generateJWT)({
                    secretKey: this.accessToken,
                    payload: {
                        ...claims,
                        scopes: [`write:waitpoints:${data.id}`],
                    },
                    expirationTime: "24h",
                });
                return {
                    ...data,
                    publicAccessToken: jwt,
                };
            },
        });
    }
    listWaitpointTokens(params, requestOptions) {
        const searchParams = createSearchQueryForListWaitpointTokens(params);
        return (0, core_js_1.zodfetchCursorPage)(index_js_1.WaitpointTokenItem, `${this.baseUrl}/api/v1/waitpoints/tokens`, {
            query: searchParams,
            limit: params?.limit,
            after: params?.after,
            before: params?.before,
        }, {
            method: "GET",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    retrieveWaitpointToken(friendlyId, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.WaitpointRetrieveTokenResponse, `${this.baseUrl}/api/v1/waitpoints/tokens/${friendlyId}`, {
            method: "GET",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    completeWaitpointToken(friendlyId, options, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.CompleteWaitpointTokenResponseBody, `${this.baseUrl}/api/v1/waitpoints/tokens/${friendlyId}/complete`, {
            method: "POST",
            headers: this.#getHeaders(false),
            body: JSON.stringify(options),
        }, {
            ...mergeRequestOptions(this.defaultRequestOptions, requestOptions),
        });
    }
    waitForWaitpointToken({ runFriendlyId, waitpointFriendlyId, }, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.WaitForWaitpointTokenResponseBody, `${this.baseUrl}/engine/v1/runs/${runFriendlyId}/waitpoints/tokens/${waitpointFriendlyId}/wait`, {
            method: "POST",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    async waitForDuration(runId, body, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.WaitForDurationResponseBody, `${this.baseUrl}/engine/v1/runs/${runId}/wait/duration`, {
            method: "POST",
            headers: this.#getHeaders(false),
            body: JSON.stringify(body),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    listQueues(options, requestOptions) {
        const searchParams = new URLSearchParams();
        if (options?.page) {
            searchParams.append("page", options.page.toString());
        }
        if (options?.perPage) {
            searchParams.append("perPage", options.perPage.toString());
        }
        return (0, core_js_1.zodfetchOffsetLimitPage)(index_js_1.QueueItem, `${this.baseUrl}/api/v1/queues`, {
            page: options?.page,
            limit: options?.perPage,
        }, {
            method: "GET",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    retrieveQueue(queue, requestOptions) {
        const type = typeof queue === "string" ? "id" : queue.type;
        const value = typeof queue === "string" ? queue : queue.name;
        // Explicitly encode slashes before encoding the rest of the string
        const encodedValue = encodeURIComponent(value.replace(/\//g, "%2F"));
        return (0, core_js_1.zodfetch)(index_js_1.QueueItem, `${this.baseUrl}/api/v1/queues/${encodedValue}?type=${type}`, {
            method: "GET",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    pauseQueue(queue, action, requestOptions) {
        const type = typeof queue === "string" ? "id" : queue.type;
        const value = typeof queue === "string" ? queue : queue.name;
        // Explicitly encode slashes before encoding the rest of the string
        const encodedValue = encodeURIComponent(value.replace(/\//g, "%2F"));
        return (0, core_js_1.zodfetch)(index_js_1.QueueItem, `${this.baseUrl}/api/v1/queues/${encodedValue}/pause`, {
            method: "POST",
            headers: this.#getHeaders(false),
            body: JSON.stringify({
                type,
                action,
            }),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    subscribeToRun(runId, options) {
        const queryParams = new URLSearchParams();
        if (options?.skipColumns) {
            queryParams.append("skipColumns", options.skipColumns.join(","));
        }
        return (0, runStream_js_1.runShapeStream)(`${this.baseUrl}/realtime/v1/runs/${runId}${queryParams ? `?${queryParams}` : ""}`, {
            closeOnComplete: typeof options?.closeOnComplete === "boolean" ? options.closeOnComplete : true,
            headers: this.#getRealtimeHeaders(),
            client: this,
            signal: options?.signal,
            onFetchError: options?.onFetchError,
        });
    }
    subscribeToRunsWithTag(tag, filters, options) {
        const searchParams = createSearchQueryForSubscribeToRuns({
            tags: tag,
            ...(filters ? { createdAt: filters.createdAt } : {}),
            ...(filters?.skipColumns ? { skipColumns: filters.skipColumns } : {}),
        });
        return (0, runStream_js_1.runShapeStream)(`${this.baseUrl}/realtime/v1/runs${searchParams ? `?${searchParams}` : ""}`, {
            closeOnComplete: false,
            headers: this.#getRealtimeHeaders(),
            client: this,
            signal: options?.signal,
            onFetchError: options?.onFetchError,
        });
    }
    subscribeToBatch(batchId, options) {
        const queryParams = new URLSearchParams();
        if (options?.skipColumns) {
            queryParams.append("skipColumns", options.skipColumns.join(","));
        }
        return (0, runStream_js_1.runShapeStream)(`${this.baseUrl}/realtime/v1/batches/${batchId}${queryParams ? `?${queryParams}` : ""}`, {
            closeOnComplete: false,
            headers: this.#getRealtimeHeaders(),
            client: this,
            signal: options?.signal,
            onFetchError: options?.onFetchError,
        });
    }
    async fetchStream(runId, streamKey, options) {
        const streamFactory = new runStream_js_1.SSEStreamSubscriptionFactory(options?.baseUrl ?? this.baseUrl, {
            headers: this.getHeaders(),
            signal: options?.signal,
        });
        const subscription = streamFactory.createSubscription(runId, streamKey);
        const stream = await subscription.subscribe();
        return stream;
    }
    async generateJWTClaims(requestOptions) {
        return (0, core_js_1.zodfetch)(zod_1.z.record(zod_1.z.any()), `${this.baseUrl}/api/v1/auth/jwt/claims`, {
            method: "POST",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    retrieveBatch(batchId, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.RetrieveBatchV2Response, `${this.baseUrl}/api/v2/batches/${batchId}`, {
            method: "GET",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    #getHeaders(spanParentAsLink, additionalHeaders) {
        const headers = {
            "Content-Type": "application/json",
            Authorization: `Bearer ${this.accessToken}`,
            "trigger-version": version_js_1.VERSION,
            ...Object.entries(additionalHeaders ?? {}).reduce((acc, [key, value]) => {
                if (value !== undefined) {
                    acc[key] = value;
                }
                return acc;
            }, {}),
        };
        if (this.previewBranch) {
            headers["x-trigger-branch"] = this.previewBranch;
        }
        // Only inject the context if we are inside a task
        if (task_context_api_js_1.taskContext.isInsideTask) {
            headers["x-trigger-worker"] = "true";
            // Only pass the engine version if we are inside a task
            headers["x-trigger-engine-version"] = "V2";
            if (spanParentAsLink) {
                headers["x-trigger-span-parent-as-link"] = "1";
            }
        }
        if (typeof window !== "undefined" && typeof window.document !== "undefined") {
            headers["x-trigger-client"] = "browser";
        }
        headers[version_js_2.API_VERSION_HEADER_NAME] = version_js_2.API_VERSION;
        return headers;
    }
    #getRealtimeHeaders() {
        let headers = {
            Authorization: `Bearer ${this.accessToken}`,
            "trigger-version": version_js_1.VERSION,
        };
        if (this.previewBranch) {
            headers["x-trigger-branch"] = this.previewBranch;
        }
        return headers;
    }
}
exports.ApiClient = ApiClient;
function createSearchQueryForSubscribeToRuns(query) {
    const searchParams = new URLSearchParams();
    if (query) {
        if (query.tasks) {
            searchParams.append("tasks", Array.isArray(query.tasks) ? query.tasks.join(",") : query.tasks);
        }
        if (query.tags) {
            searchParams.append("tags", Array.isArray(query.tags) ? query.tags.join(",") : query.tags);
        }
        if (query.createdAt) {
            searchParams.append("createdAt", query.createdAt);
        }
        if (query.skipColumns) {
            searchParams.append("skipColumns", query.skipColumns.join(","));
        }
    }
    return searchParams;
}
function createSearchQueryForListRuns(query) {
    const searchParams = new URLSearchParams();
    if (query) {
        if (query.status) {
            searchParams.append("filter[status]", Array.isArray(query.status) ? query.status.join(",") : query.status);
        }
        if (query.taskIdentifier) {
            searchParams.append("filter[taskIdentifier]", Array.isArray(query.taskIdentifier) ? query.taskIdentifier.join(",") : query.taskIdentifier);
        }
        if (query.version) {
            searchParams.append("filter[version]", Array.isArray(query.version) ? query.version.join(",") : query.version);
        }
        if (query.bulkAction) {
            searchParams.append("filter[bulkAction]", query.bulkAction);
        }
        if (query.tag) {
            searchParams.append("filter[tag]", Array.isArray(query.tag) ? query.tag.join(",") : query.tag);
        }
        if (query.schedule) {
            searchParams.append("filter[schedule]", query.schedule);
        }
        if (typeof query.isTest === "boolean") {
            searchParams.append("filter[isTest]", String(query.isTest));
        }
        if (query.from) {
            searchParams.append("filter[createdAt][from]", query.from instanceof Date ? query.from.getTime().toString() : query.from.toString());
        }
        if (query.to) {
            searchParams.append("filter[createdAt][to]", query.to instanceof Date ? query.to.getTime().toString() : query.to.toString());
        }
        if (query.period) {
            searchParams.append("filter[createdAt][period]", query.period);
        }
        if (query.batch) {
            searchParams.append("filter[batch]", query.batch);
        }
        if (query.queue) {
            searchParams.append("filter[queue]", Array.isArray(query.queue)
                ? query.queue.map((q) => queueNameFromQueueTypeName(q)).join(",")
                : queueNameFromQueueTypeName(query.queue));
        }
        if (query.machine) {
            searchParams.append("filter[machine]", Array.isArray(query.machine) ? query.machine.join(",") : query.machine);
        }
    }
    return searchParams;
}
function queueNameFromQueueTypeName(queue) {
    if (queue.type === "task") {
        return `task/${queue.name}`;
    }
    return queue.name;
}
function createSearchQueryForListWaitpointTokens(query) {
    const searchParams = new URLSearchParams();
    if (query) {
        if (query.status) {
            searchParams.append("filter[status]", Array.isArray(query.status) ? query.status.join(",") : query.status);
        }
        if (query.idempotencyKey) {
            searchParams.append("filter[idempotencyKey]", query.idempotencyKey);
        }
        if (query.tags) {
            searchParams.append("filter[tags]", Array.isArray(query.tags) ? query.tags.join(",") : query.tags);
        }
        if (query.period) {
            searchParams.append("filter[createdAt][period]", query.period);
        }
        if (query.from) {
            searchParams.append("filter[createdAt][from]", query.from instanceof Date ? query.from.getTime().toString() : query.from.toString());
        }
        if (query.to) {
            searchParams.append("filter[createdAt][to]", query.to instanceof Date ? query.to.getTime().toString() : query.to.toString());
        }
    }
    return searchParams;
}
function mergeRequestOptions(defaultOptions, options) {
    if (!options) {
        return defaultOptions;
    }
    return {
        ...defaultOptions,
        ...options,
        retry: {
            ...defaultOptions.retry,
            ...options.retry,
        },
    };
}
//# sourceMappingURL=index.js.map