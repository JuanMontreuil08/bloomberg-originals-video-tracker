"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LineTransformStream = void 0;
exports.zodShapeStream = zodShapeStream;
const client_1 = require("@electric-sql/client");
const asyncIterableStream_js_1 = require("../streams/asyncIterableStream.js");
const version_js_1 = require("./version.js");
function zodShapeStream(schema, url, options) {
    const abortController = new AbortController();
    options?.signal?.addEventListener("abort", () => {
        abortController.abort();
    }, { once: true });
    const shapeStream = new client_1.ShapeStream({
        url,
        headers: {
            ...options?.headers,
            "x-trigger-electric-version": "1.0.0-beta.1",
            [version_js_1.API_VERSION_HEADER_NAME]: version_js_1.API_VERSION,
        },
        fetchClient: options?.fetchClient,
        signal: abortController.signal,
        onError: (e) => {
            options?.onError?.(e);
        },
    });
    const readableShape = new ReadableShapeStream(shapeStream);
    const stream = readableShape.stream.pipeThrough(new TransformStream({
        async transform(chunk, controller) {
            const result = schema.safeParse(chunk);
            if (result.success) {
                controller.enqueue(result.data);
            }
            else {
                controller.error(new Error(`Unable to parse shape: ${result.error.message}`));
            }
        },
    }));
    return {
        stream: stream,
        stop: (delay) => {
            if (delay) {
                setTimeout(() => {
                    if (abortController.signal.aborted)
                        return;
                    abortController.abort();
                }, delay);
            }
            else {
                abortController.abort();
            }
        },
    };
}
class ReadableShapeStream {
    #stream;
    #currentState = new Map();
    #changeStream;
    #error = false;
    #unsubscribe;
    #isStreamClosed = false;
    stop() {
        this.#isStreamClosed = true;
        this.#unsubscribe?.();
    }
    constructor(stream) {
        this.#stream = stream;
        // Create the source stream that will receive messages
        const source = new ReadableStream({
            start: (controller) => {
                this.#unsubscribe = this.#stream.subscribe((messages) => {
                    if (!this.#isStreamClosed) {
                        controller.enqueue(messages);
                    }
                }, this.#handleError.bind(this));
            },
            cancel: () => {
                this.#isStreamClosed = true;
                this.#unsubscribe?.();
            },
        });
        let updatedKeys = new Set();
        // Create the transformed stream that processes messages and emits complete rows
        this.#changeStream = (0, asyncIterableStream_js_1.createAsyncIterableStream)(source, {
            transform: (messages, controller) => {
                if (this.#isStreamClosed) {
                    return;
                }
                try {
                    let isUpToDate = false;
                    for (const message of messages) {
                        if ((0, client_1.isChangeMessage)(message)) {
                            const key = message.key;
                            switch (message.headers.operation) {
                                case "insert": {
                                    this.#currentState.set(key, message.value);
                                    updatedKeys.add(key);
                                    break;
                                }
                                case "update": {
                                    const existingRow = this.#currentState.get(key);
                                    const updatedRow = existingRow
                                        ? { ...existingRow, ...message.value }
                                        : message.value;
                                    this.#currentState.set(key, updatedRow);
                                    updatedKeys.add(key);
                                    break;
                                }
                            }
                        }
                        else if ((0, client_1.isControlMessage)(message)) {
                            if (message.headers.control === "must-refetch") {
                                this.#currentState.clear();
                                this.#error = false;
                            }
                            else if (message.headers.control === "up-to-date") {
                                isUpToDate = true;
                            }
                        }
                    }
                    // Now enqueue only one updated row per key, after all messages have been processed.
                    // If the stream is not up to date, we don't want to enqueue any rows.
                    if (!this.#isStreamClosed && isUpToDate) {
                        for (const key of updatedKeys) {
                            const finalRow = this.#currentState.get(key);
                            if (finalRow) {
                                controller.enqueue(finalRow);
                            }
                        }
                        updatedKeys.clear();
                    }
                }
                catch (error) {
                    console.error("Error processing stream messages:", error);
                    this.#handleError(error);
                }
            },
        });
    }
    get stream() {
        return this.#changeStream;
    }
    get isUpToDate() {
        return this.#stream.isUpToDate;
    }
    get lastOffset() {
        return this.#stream.lastOffset;
    }
    get handle() {
        return this.#stream.shapeHandle;
    }
    get error() {
        return this.#error;
    }
    lastSyncedAt() {
        return this.#stream.lastSyncedAt();
    }
    lastSynced() {
        return this.#stream.lastSynced();
    }
    isLoading() {
        return this.#stream.isLoading();
    }
    isConnected() {
        return this.#stream.isConnected();
    }
    #handleError(e) {
        if (e instanceof client_1.FetchError) {
            this.#error = e;
        }
        this.#isStreamClosed = true;
        this.#unsubscribe?.();
    }
}
class LineTransformStream extends TransformStream {
    buffer = "";
    constructor() {
        super({
            transform: (chunk, controller) => {
                // Append the chunk to the buffer
                this.buffer += chunk;
                // Split on newlines
                const lines = this.buffer.split("\n");
                // The last element might be incomplete, hold it back in buffer
                this.buffer = lines.pop() || "";
                // Filter out empty or whitespace-only lines
                const fullLines = lines.filter((line) => line.trim().length > 0);
                // If we got any complete lines, emit them as an array
                if (fullLines.length > 0) {
                    controller.enqueue(fullLines);
                }
            },
            flush: (controller) => {
                // On stream end, if there's leftover text, emit it as a single-element array
                const trimmed = this.buffer.trim();
                if (trimmed.length > 0) {
                    controller.enqueue([trimmed]);
                }
            },
        });
    }
}
exports.LineTransformStream = LineTransformStream;
//# sourceMappingURL=stream.js.map