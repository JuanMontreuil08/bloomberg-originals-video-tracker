"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SupervisorSession = void 0;
const http_js_1 = require("./http.js");
const queueConsumer_js_1 = require("./queueConsumer.js");
const events_1 = __importDefault(require("events"));
const version_js_1 = require("../../../version.js");
const socket_io_client_1 = require("socket.io-client");
const util_js_1 = require("./util.js");
const interval_js_1 = require("../../utils/interval.js");
const structuredLogger_js_1 = require("../../utils/structuredLogger.js");
class SupervisorSession extends events_1.default {
    opts;
    httpClient;
    logger = new structuredLogger_js_1.SimpleStructuredLogger("supervisor-session");
    runNotificationsEnabled;
    runNotificationsSocket;
    queueConsumerEnabled;
    queueConsumers;
    heartbeat;
    constructor(opts) {
        super();
        this.opts = opts;
        this.runNotificationsEnabled = opts.runNotificationsEnabled ?? true;
        this.queueConsumerEnabled = opts.queueConsumerEnabled ?? true;
        this.httpClient = new http_js_1.SupervisorHttpClient(opts);
        this.queueConsumers = Array.from({ length: opts.maxConsumerCount ?? 1 }, () => {
            return new queueConsumer_js_1.RunQueueConsumer({
                client: this.httpClient,
                preDequeue: opts.preDequeue,
                preSkip: opts.preSkip,
                onDequeue: this.onDequeue.bind(this),
                intervalMs: opts.dequeueIntervalMs,
                idleIntervalMs: opts.dequeueIdleIntervalMs,
                maxRunCount: opts.maxRunCount,
            });
        });
        this.heartbeat = new interval_js_1.IntervalService({
            onInterval: async () => {
                this.logger.debug("Sending heartbeat");
                const body = this.getHeartbeatBody();
                const response = await this.httpClient.heartbeatWorker(body);
                if (!response.success) {
                    this.logger.error("Heartbeat failed", { error: response.error });
                }
            },
            intervalMs: opts.heartbeatIntervalSeconds * 1000,
            leadingEdge: false,
            onError: async (error) => {
                this.logger.error("Failed to send heartbeat", { error });
            },
        });
    }
    async onDequeue(messages) {
        this.logger.verbose("Dequeued messages with contents", { count: messages.length, messages });
        for (const message of messages) {
            this.emit("runQueueMessage", {
                time: new Date(),
                message,
            });
        }
    }
    subscribeToRunNotifications(runFriendlyIds) {
        this.logger.debug("Subscribing to run notifications", { runFriendlyIds });
        if (!this.runNotificationsSocket) {
            this.logger.error("Socket not connected");
            return;
        }
        this.runNotificationsSocket.emit("run:subscribe", { version: "1", runFriendlyIds });
        Promise.allSettled(runFriendlyIds.map((runFriendlyId) => this.httpClient.sendDebugLog(runFriendlyId, {
            time: new Date(),
            message: "run:subscribe supervisor -> platform",
        })));
    }
    unsubscribeFromRunNotifications(runFriendlyIds) {
        this.logger.debug("Unsubscribing from run notifications", { runFriendlyIds });
        if (!this.runNotificationsSocket) {
            this.logger.error("Socket not connected");
            return;
        }
        this.runNotificationsSocket.emit("run:unsubscribe", { version: "1", runFriendlyIds });
        Promise.allSettled(runFriendlyIds.map((runFriendlyId) => this.httpClient.sendDebugLog(runFriendlyId, {
            time: new Date(),
            message: "run:unsubscribe supervisor -> platform",
            properties: {
                runFriendlyIds,
            },
        })));
    }
    createRunNotificationsSocket() {
        const wsUrl = new URL(this.opts.apiUrl);
        wsUrl.pathname = "/worker";
        const socket = (0, socket_io_client_1.io)(wsUrl.href, {
            transports: ["websocket"],
            extraHeaders: (0, util_js_1.getDefaultWorkerHeaders)(this.opts),
        });
        socket.on("run:notify", ({ version, run }) => {
            this.logger.debug("[WS] Received run notification", { version, run });
            this.emit("runNotification", { time: new Date(), run });
            this.httpClient.sendDebugLog(run.friendlyId, {
                time: new Date(),
                message: "run:notify received by supervisor",
            });
        });
        socket.on("connect", () => {
            this.logger.log("[WS] Connected to platform");
        });
        socket.on("connect_error", (error) => {
            this.logger.error("[WS] Connection error", { error });
        });
        socket.on("disconnect", (reason, description) => {
            this.logger.log("[WS] Disconnected from platform", { reason, description });
        });
        return socket;
    }
    async start() {
        const connect = await this.httpClient.connect({
            metadata: {
                workerVersion: version_js_1.VERSION,
            },
        });
        if (!connect.success) {
            this.logger.error("Failed to connect", { error: connect.error });
            throw new Error("[SupervisorSession] Failed to connect");
        }
        const { workerGroup } = connect.data;
        this.logger.log("Connected to platform", {
            type: workerGroup.type,
            name: workerGroup.name,
        });
        if (this.queueConsumerEnabled) {
            this.logger.log("Queue consumer enabled");
            await Promise.allSettled(this.queueConsumers.map(async (q) => q.start()));
            this.heartbeat.start();
        }
        else {
            this.logger.warn("Queue consumer disabled");
        }
        if (this.runNotificationsEnabled) {
            this.logger.log("Run notifications enabled");
            this.runNotificationsSocket = this.createRunNotificationsSocket();
        }
        else {
            this.logger.warn("Run notifications disabled");
        }
    }
    async stop() {
        await Promise.allSettled(this.queueConsumers.map(async (q) => q.stop()));
        this.heartbeat.stop();
        this.runNotificationsSocket?.disconnect();
    }
    getHeartbeatBody() {
        return {
            cpu: {
                used: 0.5,
                available: 0.5,
            },
            memory: {
                used: 0.5,
                available: 0.5,
            },
            tasks: [],
        };
    }
}
exports.SupervisorSession = SupervisorSession;
//# sourceMappingURL=session.js.map