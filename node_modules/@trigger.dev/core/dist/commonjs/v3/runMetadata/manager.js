"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StandardMetadataManager = void 0;
const lite_1 = require("dequal/lite");
const metadataStream_js_1 = require("./metadataStream.js");
const operations_js_1 = require("./operations.js");
const ioSerialization_js_1 = require("../utils/ioSerialization.js");
const MAXIMUM_ACTIVE_STREAMS = 5;
const MAXIMUM_TOTAL_STREAMS = 10;
class StandardMetadataManager {
    apiClient;
    streamsBaseUrl;
    streamsVersion;
    flushTimeoutId = null;
    isFlushing = false;
    store;
    // Add a Map to track active streams
    activeStreams = new Map();
    queuedOperations = new Set();
    queuedParentOperations = new Set();
    queuedRootOperations = new Set();
    runId;
    runIdIsRoot = false;
    constructor(apiClient, streamsBaseUrl, streamsVersion = "v1") {
        this.apiClient = apiClient;
        this.streamsBaseUrl = streamsBaseUrl;
        this.streamsVersion = streamsVersion;
    }
    reset() {
        this.queuedOperations.clear();
        this.queuedParentOperations.clear();
        this.queuedRootOperations.clear();
        this.activeStreams.clear();
        this.store = undefined;
        this.runId = undefined;
        this.runIdIsRoot = false;
        if (this.flushTimeoutId) {
            clearTimeout(this.flushTimeoutId);
            this.flushTimeoutId = null;
        }
        this.isFlushing = false;
    }
    get parent() {
        // Store a reference to 'this' to ensure proper context
        const self = this;
        // Create the updater object and store it in a local variable
        const parentUpdater = {
            set: (key, value) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.set(key, value);
                }
                self.queuedParentOperations.add({ type: "set", key, value });
                return parentUpdater;
            },
            del: (key) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.del(key);
                }
                self.queuedParentOperations.add({ type: "delete", key });
                return parentUpdater;
            },
            append: (key, value) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.append(key, value);
                }
                self.queuedParentOperations.add({ type: "append", key, value });
                return parentUpdater;
            },
            remove: (key, value) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.remove(key, value);
                }
                self.queuedParentOperations.add({ type: "remove", key, value });
                return parentUpdater;
            },
            increment: (key, value) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.increment(key, value);
                }
                self.queuedParentOperations.add({ type: "increment", key, value });
                return parentUpdater;
            },
            decrement: (key, value) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.decrement(key, value);
                }
                self.queuedParentOperations.add({ type: "increment", key, value: -Math.abs(value) });
                return parentUpdater;
            },
            update: (value) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.update(value);
                }
                self.queuedParentOperations.add({ type: "update", value });
                return parentUpdater;
            },
            stream: (key, value, signal) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.doStream(key, value, "self", parentUpdater, signal);
                }
                return self.doStream(key, value, "parent", parentUpdater, signal);
            },
        };
        return parentUpdater;
    }
    get root() {
        // Store a reference to 'this' to ensure proper context
        const self = this;
        // Create the updater object and store it in a local variable
        const rootUpdater = {
            set: (key, value) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.set(key, value);
                }
                self.queuedRootOperations.add({ type: "set", key, value });
                return rootUpdater;
            },
            del: (key) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.del(key);
                }
                self.queuedRootOperations.add({ type: "delete", key });
                return rootUpdater;
            },
            append: (key, value) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.append(key, value);
                }
                self.queuedRootOperations.add({ type: "append", key, value });
                return rootUpdater;
            },
            remove: (key, value) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.remove(key, value);
                }
                self.queuedRootOperations.add({ type: "remove", key, value });
                return rootUpdater;
            },
            increment: (key, value) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.increment(key, value);
                }
                self.queuedRootOperations.add({ type: "increment", key, value });
                return rootUpdater;
            },
            decrement: (key, value) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.decrement(key, value);
                }
                self.queuedRootOperations.add({ type: "increment", key, value: -Math.abs(value) });
                return rootUpdater;
            },
            update: (value) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.update(value);
                }
                self.queuedRootOperations.add({ type: "update", value });
                return rootUpdater;
            },
            stream: (key, value, signal) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.doStream(key, value, "self", rootUpdater, signal);
                }
                return self.doStream(key, value, "root", rootUpdater, signal);
            },
        };
        return rootUpdater;
    }
    enterWithMetadata(metadata) {
        this.store = metadata ?? {};
    }
    current() {
        return this.store;
    }
    getKey(key) {
        return this.store?.[key];
    }
    enqueueOperation(operation) {
        const applyResults = (0, operations_js_1.applyMetadataOperations)(this.store ?? {}, operation);
        if (applyResults.unappliedOperations.length > 0) {
            return;
        }
        if ((0, lite_1.dequal)(this.store, applyResults.newMetadata)) {
            return;
        }
        this.queuedOperations.add(operation);
        this.store = applyResults.newMetadata;
    }
    set(key, value) {
        if (!this.runId) {
            return this;
        }
        this.enqueueOperation({ type: "set", key, value });
        return this;
    }
    del(key) {
        if (!this.runId) {
            return this;
        }
        this.enqueueOperation({ type: "delete", key });
        return this;
    }
    append(key, value) {
        if (!this.runId) {
            return this;
        }
        this.enqueueOperation({ type: "append", key, value });
        return this;
    }
    remove(key, value) {
        if (!this.runId) {
            return this;
        }
        this.enqueueOperation({ type: "remove", key, value });
        return this;
    }
    increment(key, increment = 1) {
        if (!this.runId) {
            return this;
        }
        this.enqueueOperation({ type: "increment", key, value: increment });
        return this;
    }
    decrement(key, decrement = 1) {
        return this.increment(key, -decrement);
    }
    update(metadata) {
        if (!this.runId) {
            return this;
        }
        this.enqueueOperation({ type: "update", value: metadata });
        return this;
    }
    async stream(key, value, signal) {
        return this.doStream(key, value, "self", this, signal);
    }
    async fetchStream(key, signal) {
        if (!this.runId) {
            throw new Error("Run ID is required to fetch metadata streams.");
        }
        const baseUrl = this.getKey("$$streamsBaseUrl");
        const $baseUrl = typeof baseUrl === "string" ? baseUrl : this.streamsBaseUrl;
        return this.apiClient.fetchStream(this.runId, key, { baseUrl: $baseUrl, signal });
    }
    async doStream(key, value, target, updater = this, signal) {
        const $value = value;
        if (!this.runId) {
            return $value;
        }
        // Check to make sure we haven't exceeded the max number of active streams
        if (this.activeStreams.size >= MAXIMUM_ACTIVE_STREAMS) {
            console.warn(`Exceeded the maximum number of active streams (${MAXIMUM_ACTIVE_STREAMS}). The "${key}" stream will be ignored.`);
            return $value;
        }
        // Check to make sure we haven't exceeded the max number of total streams
        const streams = (this.store?.$$streams ?? []);
        if (streams.length >= MAXIMUM_TOTAL_STREAMS) {
            console.warn(`Exceeded the maximum number of total streams (${MAXIMUM_TOTAL_STREAMS}). The "${key}" stream will be ignored.`);
            return $value;
        }
        try {
            const streamInstance = new metadataStream_js_1.MetadataStream({
                key,
                runId: this.runId,
                source: $value,
                baseUrl: this.streamsBaseUrl,
                headers: this.apiClient.getHeaders(),
                signal,
                version: this.streamsVersion,
                target,
            });
            this.activeStreams.set(key, streamInstance);
            // Clean up when stream completes
            streamInstance.wait().finally(() => this.activeStreams.delete(key));
            // Add the key to the special stream metadata object
            updater
                .append(`$$streams`, key)
                .set("$$streamsVersion", this.streamsVersion)
                .set("$$streamsBaseUrl", this.streamsBaseUrl);
            await this.flush();
            return streamInstance;
        }
        catch (error) {
            // Clean up metadata key if stream creation fails
            updater.remove(`$$streams`, key);
            throw error;
        }
    }
    hasActiveStreams() {
        return this.activeStreams.size > 0;
    }
    // Waits for all the streams to finish
    async waitForAllStreams(timeout = 60_000) {
        if (this.activeStreams.size === 0) {
            return;
        }
        const promises = Array.from(this.activeStreams.values()).map((stream) => stream.wait());
        try {
            await Promise.race([
                Promise.allSettled(promises),
                new Promise((resolve, _) => setTimeout(() => resolve(), timeout)),
            ]);
        }
        catch (error) {
            console.error("Error waiting for streams to finish:", error);
            // If we time out, abort all remaining streams
            for (const [key, promise] of this.activeStreams.entries()) {
                // We can add abort logic here if needed
                this.activeStreams.delete(key);
            }
            throw error;
        }
    }
    async refresh(requestOptions) {
        if (!this.runId) {
            return;
        }
        try {
            const metadata = await this.apiClient.getRunMetadata(this.runId, requestOptions);
            this.store = metadata.metadata;
        }
        catch (error) {
            console.error("Failed to refresh metadata", error);
            throw error;
        }
    }
    async flush(requestOptions) {
        if (!this.runId) {
            return;
        }
        if (!this.#needsFlush()) {
            return;
        }
        if (this.isFlushing) {
            return;
        }
        this.isFlushing = true;
        const operations = Array.from(this.queuedOperations);
        this.queuedOperations.clear();
        const parentOperations = Array.from(this.queuedParentOperations);
        this.queuedParentOperations.clear();
        const rootOperations = Array.from(this.queuedRootOperations);
        this.queuedRootOperations.clear();
        try {
            const collapsedOperations = (0, operations_js_1.collapseOperations)(operations);
            const collapsedParentOperations = (0, operations_js_1.collapseOperations)(parentOperations);
            const collapsedRootOperations = (0, operations_js_1.collapseOperations)(rootOperations);
            const response = await this.apiClient.updateRunMetadata(this.runId, {
                operations: collapsedOperations,
                parentOperations: collapsedParentOperations,
                rootOperations: collapsedRootOperations,
            }, requestOptions);
            this.store = response.metadata;
        }
        catch (error) {
            console.error("Failed to flush metadata", error);
        }
        finally {
            this.isFlushing = false;
        }
    }
    startPeriodicFlush(intervalMs = 1000) {
        const periodicFlush = async (intervalMs) => {
            if (this.isFlushing) {
                return;
            }
            try {
                await this.flush();
            }
            catch (error) {
                console.error("Failed to flush metadata", error);
                throw error;
            }
            finally {
                this.isFlushing = false;
                scheduleNext();
            }
        };
        const scheduleNext = () => {
            this.flushTimeoutId = setTimeout(() => periodicFlush(intervalMs), intervalMs);
        };
        scheduleNext();
    }
    stopPeriodicFlush() {
        if (this.flushTimeoutId) {
            clearTimeout(this.flushTimeoutId);
            this.flushTimeoutId = null;
        }
    }
    async stopAndReturnLastFlush() {
        this.stopPeriodicFlush();
        this.isFlushing = true;
        if (!this.#needsFlush()) {
            return { dataType: "application/json" };
        }
        const operations = Array.from(this.queuedOperations);
        const parentOperations = Array.from(this.queuedParentOperations);
        const rootOperations = Array.from(this.queuedRootOperations);
        const data = {
            operations: (0, operations_js_1.collapseOperations)(operations),
            parentOperations: (0, operations_js_1.collapseOperations)(parentOperations),
            rootOperations: (0, operations_js_1.collapseOperations)(rootOperations),
        };
        const packet = await (0, ioSerialization_js_1.stringifyIO)(data);
        return packet;
    }
    #needsFlush() {
        return (this.queuedOperations.size > 0 ||
            this.queuedParentOperations.size > 0 ||
            this.queuedRootOperations.size > 0);
    }
}
exports.StandardMetadataManager = StandardMetadataManager;
//# sourceMappingURL=manager.js.map