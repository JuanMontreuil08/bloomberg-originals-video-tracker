"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vitest_1 = require("vitest");
const shutdownManager_js_1 = require("./shutdownManager.js");
(0, vitest_1.describe)("ShutdownManager", { concurrent: false }, () => {
    // Mock process.exit to prevent actual exit
    const mockExit = vitest_1.vi.spyOn(process, "exit").mockImplementation(() => undefined);
    (0, vitest_1.beforeEach)(() => {
        vitest_1.vi.clearAllMocks();
    });
    (0, vitest_1.test)("should successfully register a new handler", () => {
        const manager = new shutdownManager_js_1.ShutdownManager(false);
        const handler = vitest_1.vi.fn();
        manager.register("test-handler", handler);
        (0, vitest_1.expect)(manager._getHandlersForTesting().has("test-handler")).toBe(true);
        const registeredHandler = manager._getHandlersForTesting().get("test-handler");
        (0, vitest_1.expect)(registeredHandler?.handler).toBe(handler);
        (0, vitest_1.expect)(registeredHandler?.signals).toEqual(["SIGTERM", "SIGINT"]);
    });
    (0, vitest_1.test)("should throw error when registering duplicate handler name", () => {
        const manager = new shutdownManager_js_1.ShutdownManager(false);
        const handler = vitest_1.vi.fn();
        manager.register("duplicate-handler", handler);
        (0, vitest_1.expect)(() => {
            manager.register("duplicate-handler", handler);
        }).toThrow('Shutdown handler "duplicate-handler" already registered');
    });
    (0, vitest_1.test)("should register handler with custom signals", () => {
        const manager = new shutdownManager_js_1.ShutdownManager(false);
        const handler = vitest_1.vi.fn();
        manager.register("custom-signals", handler, ["SIGTERM"]);
        const registeredHandler = manager._getHandlersForTesting().get("custom-signals");
        (0, vitest_1.expect)(registeredHandler?.signals).toEqual(["SIGTERM"]);
    });
    (0, vitest_1.test)("should call registered handlers when shutdown is triggered", async () => {
        const manager = new shutdownManager_js_1.ShutdownManager(false);
        const handler1 = vitest_1.vi.fn();
        const handler2 = vitest_1.vi.fn();
        manager.register("handler1", handler1);
        manager.register("handler2", handler2);
        await manager.shutdown("SIGTERM");
        (0, vitest_1.expect)(handler1).toHaveBeenCalledWith("SIGTERM");
        (0, vitest_1.expect)(handler2).toHaveBeenCalledWith("SIGTERM");
        (0, vitest_1.expect)(mockExit).toHaveBeenCalledWith(128 + 15); // SIGTERM number
    });
    (0, vitest_1.test)("should only call handlers registered for specific signal", async () => {
        const manager = new shutdownManager_js_1.ShutdownManager(false);
        const handler1 = vitest_1.vi.fn();
        const handler2 = vitest_1.vi.fn();
        manager.register("handler1", handler1, ["SIGTERM"]);
        manager.register("handler2", handler2, ["SIGINT"]);
        await manager.shutdown("SIGTERM");
        (0, vitest_1.expect)(handler1).toHaveBeenCalledWith("SIGTERM");
        (0, vitest_1.expect)(handler2).not.toHaveBeenCalled();
        (0, vitest_1.expect)(mockExit).toHaveBeenCalledWith(128 + 15);
    });
    (0, vitest_1.test)("should handle errors in shutdown handlers gracefully", async () => {
        const manager = new shutdownManager_js_1.ShutdownManager(false);
        const successHandler = vitest_1.vi.fn();
        const errorHandler = vitest_1.vi.fn().mockRejectedValue(new Error("Handler failed"));
        manager.register("success-handler", successHandler);
        manager.register("error-handler", errorHandler);
        await manager.shutdown("SIGTERM");
        (0, vitest_1.expect)(successHandler).toHaveBeenCalledWith("SIGTERM");
        (0, vitest_1.expect)(errorHandler).toHaveBeenCalledWith("SIGTERM");
        (0, vitest_1.expect)(mockExit).toHaveBeenCalledWith(128 + 15);
    });
    (0, vitest_1.test)("should only run shutdown sequence once even if called multiple times", async () => {
        const manager = new shutdownManager_js_1.ShutdownManager(false);
        const handler = vitest_1.vi.fn();
        manager.register("test-handler", handler);
        await Promise.all([manager.shutdown("SIGTERM"), manager.shutdown("SIGTERM")]);
        (0, vitest_1.expect)(handler).toHaveBeenCalledTimes(1);
        (0, vitest_1.expect)(mockExit).toHaveBeenCalledTimes(1);
        (0, vitest_1.expect)(mockExit).toHaveBeenCalledWith(128 + 15);
    });
    (0, vitest_1.test)("should exit with correct signal number on SIGINT", async () => {
        const manager = new shutdownManager_js_1.ShutdownManager(false);
        manager.register("test-handler", vitest_1.vi.fn());
        await manager.shutdown("SIGINT");
        (0, vitest_1.expect)(mockExit).toHaveBeenCalledWith(128 + 2); // SIGINT number
    });
    (0, vitest_1.test)("should exit with correct signal number on SIGTERM", async () => {
        const manager = new shutdownManager_js_1.ShutdownManager(false);
        manager.register("test-handler", vitest_1.vi.fn());
        await manager.shutdown("SIGTERM");
        (0, vitest_1.expect)(mockExit).toHaveBeenCalledWith(128 + 15); // SIGTERM number
    });
    (0, vitest_1.test)("should only exit after all handlers have finished", async () => {
        const sequence = [];
        const manager = new shutdownManager_js_1.ShutdownManager(false);
        const handler1 = vitest_1.vi.fn().mockImplementation(async () => {
            sequence.push("handler1 start");
            await new Promise((resolve) => setTimeout(resolve, 10));
            sequence.push("handler1 end");
        });
        const handler2 = vitest_1.vi.fn().mockImplementation(async () => {
            sequence.push("handler2 start");
            await new Promise((resolve) => setTimeout(resolve, 20));
            sequence.push("handler2 end");
        });
        const handler3 = vitest_1.vi.fn().mockImplementation(async () => {
            sequence.push("handler3 start");
            await new Promise((resolve) => setTimeout(resolve, 5));
            sequence.push("handler3 end");
        });
        // Store the current mock implementation
        const currentExit = mockExit.getMockImplementation();
        // Override with our sequence-tracking implementation
        mockExit.mockImplementation((code) => {
            sequence.push("exit");
            return undefined;
        });
        manager.register("handler1", handler1);
        manager.register("handler2", handler2);
        manager.register("handler3", handler3);
        await manager.shutdown("SIGTERM");
        // Verify the execution order
        (0, vitest_1.expect)(sequence).toEqual([
            "handler1 start",
            "handler2 start",
            "handler3 start",
            "handler3 end",
            "handler1 end",
            "handler2 end",
            "exit",
        ]);
        // Verify the handlers were called with correct arguments
        (0, vitest_1.expect)(handler1).toHaveBeenCalledWith("SIGTERM");
        (0, vitest_1.expect)(handler2).toHaveBeenCalledWith("SIGTERM");
        (0, vitest_1.expect)(handler3).toHaveBeenCalledWith("SIGTERM");
        (0, vitest_1.expect)(mockExit).toHaveBeenCalledWith(128 + 15);
        // Restore original mock implementation
        if (currentExit) {
            mockExit.mockImplementation(currentExit);
        }
    });
});
//# sourceMappingURL=shutdownManager.test.js.map