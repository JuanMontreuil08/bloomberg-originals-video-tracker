"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAsyncIterableStream = createAsyncIterableStream;
exports.createAsyncIterableReadable = createAsyncIterableReadable;
exports.createAsyncIterableStreamFromAsyncIterable = createAsyncIterableStreamFromAsyncIterable;
exports.createAsyncIterableStreamFromAsyncGenerator = createAsyncIterableStreamFromAsyncGenerator;
function createAsyncIterableStream(source, transformer) {
    const transformedStream = source.pipeThrough(new TransformStream(transformer));
    transformedStream[Symbol.asyncIterator] = () => {
        const reader = transformedStream.getReader();
        return {
            async next() {
                const { done, value } = await reader.read();
                return done ? { done: true, value: undefined } : { done: false, value };
            },
        };
    };
    return transformedStream;
}
function createAsyncIterableReadable(source, transformer, signal) {
    return new ReadableStream({
        async start(controller) {
            const transformedStream = source.pipeThrough(new TransformStream(transformer));
            const reader = transformedStream.getReader();
            signal.addEventListener("abort", () => {
                queueMicrotask(() => {
                    reader.cancel();
                    controller.close();
                });
            });
            while (true) {
                const { done, value } = await reader.read();
                if (done) {
                    controller.close();
                    break;
                }
                controller.enqueue(value);
            }
        },
    });
}
function createAsyncIterableStreamFromAsyncIterable(asyncIterable, transformer, signal) {
    const stream = new ReadableStream({
        async start(controller) {
            try {
                if (signal) {
                    signal.addEventListener("abort", () => {
                        controller.close();
                    });
                }
                const iterator = asyncIterable[Symbol.asyncIterator]();
                while (true) {
                    if (signal?.aborted) {
                        break;
                    }
                    const { done, value } = await iterator.next();
                    if (done) {
                        controller.close();
                        break;
                    }
                    controller.enqueue(value);
                }
            }
            catch (error) {
                controller.error(error);
            }
        },
        cancel() {
            // If the stream is a tinyexec process with a kill method, kill it
            if ("kill" in asyncIterable) {
                asyncIterable.kill();
            }
        },
    });
    const transformedStream = stream.pipeThrough(new TransformStream(transformer));
    return transformedStream;
}
function createAsyncIterableStreamFromAsyncGenerator(asyncGenerator, transformer, signal) {
    return createAsyncIterableStreamFromAsyncIterable(asyncGenerator, transformer, signal);
}
//# sourceMappingURL=asyncIterableStream.js.map