"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaskContextLogProcessor = exports.TaskContextSpanProcessor = void 0;
const api_1 = require("@opentelemetry/api");
const semanticInternalAttributes_js_1 = require("../semanticInternalAttributes.js");
const task_context_api_js_1 = require("../task-context-api.js");
const flattenAttributes_js_1 = require("../utils/flattenAttributes.js");
class TaskContextSpanProcessor {
    _innerProcessor;
    _tracer;
    constructor(version, innerProcessor) {
        this._tracer = api_1.trace.getTracer("trigger-dev-worker", version);
        this._innerProcessor = innerProcessor;
    }
    // Called when a span starts
    onStart(span, parentContext) {
        if (task_context_api_js_1.taskContext.ctx) {
            span.setAttributes((0, flattenAttributes_js_1.flattenAttributes)(task_context_api_js_1.taskContext.attributes, semanticInternalAttributes_js_1.SemanticInternalAttributes.METADATA));
        }
        if (!isPartialSpan(span) && !skipPartialSpan(span)) {
            const partialSpan = createPartialSpan(this._tracer, span, parentContext);
            partialSpan.end();
        }
        this._innerProcessor.onStart(span, parentContext);
    }
    // Delegate the rest of the methods to the wrapped processor
    onEnd(span) {
        this._innerProcessor.onEnd(span);
    }
    shutdown() {
        return this._innerProcessor.shutdown();
    }
    forceFlush() {
        return this._innerProcessor.forceFlush();
    }
}
exports.TaskContextSpanProcessor = TaskContextSpanProcessor;
function isPartialSpan(span) {
    return span.attributes[semanticInternalAttributes_js_1.SemanticInternalAttributes.SPAN_PARTIAL] === true;
}
function skipPartialSpan(span) {
    return span.attributes[semanticInternalAttributes_js_1.SemanticInternalAttributes.SKIP_SPAN_PARTIAL] === true;
}
function createPartialSpan(tracer, span, parentContext) {
    const partialSpan = tracer.startSpan(span.name, {
        attributes: {
            [semanticInternalAttributes_js_1.SemanticInternalAttributes.SPAN_PARTIAL]: true,
            [semanticInternalAttributes_js_1.SemanticInternalAttributes.SPAN_ID]: span.spanContext().spanId,
            ...span.attributes,
        },
    }, parentContext);
    if (task_context_api_js_1.taskContext.ctx) {
        partialSpan.setAttributes((0, flattenAttributes_js_1.flattenAttributes)(task_context_api_js_1.taskContext.attributes, semanticInternalAttributes_js_1.SemanticInternalAttributes.METADATA));
    }
    if (span.events) {
        for (const event of span.events) {
            partialSpan.addEvent(event.name, event.attributes, event.time);
        }
    }
    return partialSpan;
}
class TaskContextLogProcessor {
    _innerProcessor;
    constructor(innerProcessor) {
        this._innerProcessor = innerProcessor;
    }
    forceFlush() {
        return this._innerProcessor.forceFlush();
    }
    onEmit(logRecord, context) {
        // Adds in the context attributes to the log record
        if (task_context_api_js_1.taskContext.ctx) {
            logRecord.setAttributes((0, flattenAttributes_js_1.flattenAttributes)(task_context_api_js_1.taskContext.attributes, semanticInternalAttributes_js_1.SemanticInternalAttributes.METADATA));
        }
        this._innerProcessor.onEmit(logRecord, context);
    }
    shutdown() {
        return this._innerProcessor.shutdown();
    }
}
exports.TaskContextLogProcessor = TaskContextLogProcessor;
//# sourceMappingURL=otelProcessors.js.map