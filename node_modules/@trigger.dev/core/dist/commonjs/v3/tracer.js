"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TriggerTracer = void 0;
const api_1 = require("@opentelemetry/api");
const api_logs_1 = require("@opentelemetry/api-logs");
const clock_api_js_1 = require("./clock-api.js");
const errors_js_1 = require("./errors.js");
const utils_js_1 = require("./otel/utils.js");
const semanticInternalAttributes_js_1 = require("./semanticInternalAttributes.js");
const task_context_api_js_1 = require("./task-context-api.js");
const usage_api_js_1 = require("./usage-api.js");
class TriggerTracer {
    _config;
    constructor(_config) {
        this._config = _config;
    }
    _tracer;
    get tracer() {
        if (!this._tracer) {
            if ("tracer" in this._config)
                return this._config.tracer;
            this._tracer = api_1.trace.getTracer(this._config.name, this._config.version);
        }
        return this._tracer;
    }
    _logger;
    get logger() {
        if (!this._logger) {
            if ("logger" in this._config)
                return this._config.logger;
            this._logger = api_logs_1.logs.getLogger(this._config.name, this._config.version);
        }
        return this._logger;
    }
    startActiveSpan(name, fn, options, ctx, signal) {
        const parentContext = ctx ?? api_1.context.active();
        const attributes = options?.attributes ?? {};
        let spanEnded = false;
        const createPartialSpanWithEvents = options?.events && options.events.length > 0;
        return this.tracer.startActiveSpan(name, {
            ...options,
            attributes: {
                ...attributes,
                ...(createPartialSpanWithEvents
                    ? {
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.SKIP_SPAN_PARTIAL]: true,
                    }
                    : {}),
            },
            startTime: clock_api_js_1.clock.preciseNow(),
        }, parentContext, async (span) => {
            signal?.addEventListener("abort", () => {
                if (!spanEnded) {
                    spanEnded = true;
                    (0, utils_js_1.recordSpanException)(span, signal.reason);
                    span.end();
                }
            });
            if (task_context_api_js_1.taskContext.ctx && createPartialSpanWithEvents) {
                const partialSpan = this.tracer.startSpan(name, {
                    ...options,
                    attributes: {
                        ...attributes,
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.SPAN_PARTIAL]: true,
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.SPAN_ID]: span.spanContext().spanId,
                    },
                }, parentContext);
                if (options?.events) {
                    for (const event of options.events) {
                        partialSpan.addEvent(event.name, event.attributes, event.startTime);
                    }
                }
                partialSpan.end();
            }
            if (options?.events) {
                for (const event of options.events) {
                    span.addEvent(event.name, event.attributes, event.startTime);
                }
            }
            const usageMeasurement = usage_api_js_1.usage.start();
            try {
                return await fn(span);
            }
            catch (e) {
                if ((0, errors_js_1.isCompleteTaskWithOutput)(e)) {
                    if (!spanEnded) {
                        span.end(clock_api_js_1.clock.preciseNow());
                    }
                    throw e;
                }
                if (!spanEnded) {
                    if (typeof e === "string" || e instanceof Error) {
                        span.recordException(e);
                    }
                    span.setStatus({ code: api_1.SpanStatusCode.ERROR });
                }
                throw e;
            }
            finally {
                if (!spanEnded) {
                    spanEnded = true;
                    if (task_context_api_js_1.taskContext.ctx) {
                        const usageSample = usage_api_js_1.usage.stop(usageMeasurement);
                        const machine = task_context_api_js_1.taskContext.ctx.machine;
                        span.setAttributes({
                            [semanticInternalAttributes_js_1.SemanticInternalAttributes.USAGE_DURATION_MS]: usageSample.cpuTime,
                            [semanticInternalAttributes_js_1.SemanticInternalAttributes.USAGE_COST_IN_CENTS]: machine?.centsPerMs
                                ? usageSample.cpuTime * machine.centsPerMs
                                : 0,
                        });
                    }
                    span.end(clock_api_js_1.clock.preciseNow());
                }
            }
        });
    }
    startSpan(name, options, ctx) {
        const parentContext = ctx ?? api_1.context.active();
        const attributes = options?.attributes ?? {};
        const span = this.tracer.startSpan(name, options, parentContext);
        return span;
    }
}
exports.TriggerTracer = TriggerTracer;
//# sourceMappingURL=tracer.js.map