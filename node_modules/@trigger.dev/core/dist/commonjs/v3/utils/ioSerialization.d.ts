import { Attributes } from "@opentelemetry/api";
import { ApiClient } from "../apiClient/index.js";
import { TriggerTracer } from "../tracer.js";
export type IOPacket = {
    data?: string | undefined;
    dataType: string;
};
export type ParsePacketOptions = {
    filteredKeys?: string[];
};
export declare function parsePacket(value: IOPacket, options?: ParsePacketOptions): Promise<any>;
export declare function parsePacketAsJson(value: IOPacket, options?: ParsePacketOptions): Promise<any>;
export declare function conditionallyImportAndParsePacket(value: IOPacket, client?: ApiClient): Promise<any>;
export declare function stringifyIO(value: any): Promise<IOPacket>;
export declare function conditionallyExportPacket(packet: IOPacket, pathPrefix: string, tracer?: TriggerTracer): Promise<IOPacket>;
export declare function packetRequiresOffloading(packet: IOPacket, lengthLimit?: number): {
    needsOffloading: boolean;
    size: number;
};
export declare function conditionallyImportPacket(packet: IOPacket, tracer?: TriggerTracer, client?: ApiClient): Promise<IOPacket>;
export declare function resolvePresignedPacketUrl(url: string, tracer?: TriggerTracer): Promise<any | undefined>;
export declare function createPacketAttributes(packet: IOPacket, dataKey: string, dataTypeKey: string): Promise<Attributes | undefined>;
export declare function createPacketAttributesAsJson(data: any, dataType: string): Promise<Attributes>;
export declare function prettyPrintPacket(rawData: any, dataType?: string, options?: ReplacerOptions): Promise<string>;
interface ReplacerOptions {
    filteredKeys?: string[];
}
/**
 * Replaces the data in a SuperJSON-serialized string with new payload data while preserving
 * the original type metadata (Dates, BigInts, Sets, Maps, etc.).
 *
 * It is primarily useful for our run replay functionality where we want to preserve the original
 * type metadata for the new payload.
 *
 * Note that `undefined` type metadata is ignored when the corresponding field is overriden in the
 * new payload, i.e., fields which were previously undefined in the original payload are restored into
 * the primitive type they have in the new payload, instead of `undefined`.
 * This is a workaround for https://github.com/triggerdotdev/trigger.dev/issues/1968.
 *
 * @param original - A SuperJSON-serialized string containing the original data with type metadata
 * @param newPayload - A JSON string containing the new data to replace the original payload
 * @returns The deserialized object with new data but original type metadata preserved
 *
 * @throws {Error} If the newPayload is not valid JSON
 */
export declare function replaceSuperJsonPayload(original: string, newPayload: string): Promise<unknown>;
export {};
