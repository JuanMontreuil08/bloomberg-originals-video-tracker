"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaskExecutor = void 0;
const api_1 = require("@opentelemetry/api");
const utils_js_1 = require("../../utils.js");
const errors_js_1 = require("../errors.js");
const index_js_1 = require("../index.js");
const index_js_2 = require("../otel/index.js");
const run_timeline_metrics_api_js_1 = require("../run-timeline-metrics-api.js");
const index_js_3 = require("../schemas/index.js");
const semanticInternalAttributes_js_1 = require("../semanticInternalAttributes.js");
const tryCatch_js_1 = require("../tryCatch.js");
const ioSerialization_js_1 = require("../utils/ioSerialization.js");
const retries_js_1 = require("../utils/retries.js");
class TaskExecutor {
    task;
    _tracingSDK;
    _tracer;
    _consoleInterceptor;
    _retries;
    _isWarmStart;
    _executionCount;
    constructor(task, options) {
        this.task = task;
        this._tracingSDK = options.tracingSDK;
        this._tracer = options.tracer;
        this._consoleInterceptor = options.consoleInterceptor;
        this._retries = options.retries;
        this._isWarmStart = options.isWarmStart;
        this._executionCount = options.executionCount;
    }
    async execute(execution, ctx, signal) {
        const attemptMessage = `Attempt ${execution.attempt.number}`;
        const originalPacket = {
            data: execution.run.payload,
            dataType: execution.run.payloadType,
        };
        if (execution.run.metadata) {
            index_js_1.runMetadata.enterWithMetadata(execution.run.metadata);
        }
        const result = await this._tracer.startActiveSpan(attemptMessage, async (span) => {
            const attemptContext = api_1.context.active();
            return await this._consoleInterceptor.intercept(console, async () => {
                let parsedPayload;
                let initOutput;
                const [inputError, payloadResult] = await (0, tryCatch_js_1.tryCatch)(run_timeline_metrics_api_js_1.runTimelineMetrics.measureMetric("trigger.dev/execution", "payload", async () => {
                    const payloadPacket = await (0, ioSerialization_js_1.conditionallyImportPacket)(originalPacket, this._tracer);
                    return await (0, ioSerialization_js_1.parsePacket)(payloadPacket);
                }));
                if (inputError) {
                    (0, index_js_2.recordSpanException)(span, inputError);
                    return this.#internalErrorResult(execution, index_js_3.TaskRunErrorCodes.TASK_INPUT_ERROR, inputError);
                }
                const [parsePayloadError, parsedPayloadResult] = await (0, tryCatch_js_1.tryCatch)(this.#parsePayload(payloadResult));
                if (parsePayloadError) {
                    (0, index_js_2.recordSpanException)(span, parsePayloadError);
                    return this.#internalErrorResult(execution, index_js_3.TaskRunErrorCodes.TASK_INPUT_ERROR, parsePayloadError, true);
                }
                parsedPayload = parsedPayloadResult;
                index_js_1.lifecycleHooks.registerOnWaitHookListener(async (wait) => {
                    await this.#callOnWaitFunctions(wait, parsedPayload, ctx, initOutput, signal);
                });
                index_js_1.lifecycleHooks.registerOnResumeHookListener(async (wait) => {
                    await this.#callOnResumeFunctions(wait, parsedPayload, ctx, initOutput, signal);
                });
                const { promise: runPromise, resolve: runResolve, reject: runReject, } = (0, utils_js_1.promiseWithResolvers)();
                // Make sure the run promise does not cause unhandled promise rejections
                runPromise.catch(() => { });
                index_js_1.lifecycleHooks.registerOnCancelHookListener(async () => {
                    await this.#callOnCancelFunctions(runPromise, parsedPayload, ctx, initOutput, signal, attemptContext);
                });
                const executeTask = async (payload) => {
                    const [runError, output] = await (0, tryCatch_js_1.tryCatch)((async () => {
                        initOutput = await this.#callInitFunctions(payload, ctx, signal);
                        if (execution.attempt.number === 1) {
                            await this.#callOnStartFunctions(payload, ctx, initOutput, signal);
                        }
                        try {
                            return await this.#callRun(payload, ctx, initOutput, signal);
                        }
                        catch (error) {
                            if ((0, errors_js_1.isCompleteTaskWithOutput)(error)) {
                                return error.output;
                            }
                            throw error;
                        }
                    })());
                    if (runError) {
                        runReject(runError);
                        const [handleErrorError, handleErrorResult] = await (0, tryCatch_js_1.tryCatch)(this.#handleError(execution, runError, payload, ctx, initOutput, signal));
                        if (handleErrorError) {
                            (0, index_js_2.recordSpanException)(span, handleErrorError);
                            return this.#internalErrorResult(execution, index_js_3.TaskRunErrorCodes.HANDLE_ERROR_ERROR, handleErrorError);
                        }
                        (0, index_js_2.recordSpanException)(span, handleErrorResult.error ?? runError);
                        if (handleErrorResult.status !== "retry") {
                            await this.#callOnFailureFunctions(payload, handleErrorResult.error ?? runError, ctx, initOutput, signal);
                            await this.#callOnCompleteFunctions(payload, { ok: false, error: handleErrorResult.error ?? runError }, ctx, initOutput, signal);
                        }
                        await this.#cleanupAndWaitUntil(payload, ctx, initOutput, signal);
                        return {
                            id: execution.run.id,
                            ok: false,
                            error: (0, errors_js_1.sanitizeError)(handleErrorResult.error
                                ? (0, errors_js_1.parseError)(handleErrorResult.error)
                                : (0, errors_js_1.parseError)(runError)),
                            retry: handleErrorResult.status === "retry" ? handleErrorResult.retry : undefined,
                            skippedRetrying: handleErrorResult.status === "skipped",
                        };
                    }
                    runResolve(output);
                    const [outputError, stringifiedOutput] = await (0, tryCatch_js_1.tryCatch)((0, ioSerialization_js_1.stringifyIO)(output));
                    if (outputError) {
                        (0, index_js_2.recordSpanException)(span, outputError);
                        await this.#cleanupAndWaitUntil(payload, ctx, initOutput, signal);
                        return this.#internalErrorResult(execution, index_js_3.TaskRunErrorCodes.TASK_OUTPUT_ERROR, outputError);
                    }
                    const [exportError, finalOutput] = await (0, tryCatch_js_1.tryCatch)((0, ioSerialization_js_1.conditionallyExportPacket)(stringifiedOutput, `${(0, index_js_1.attemptKey)(ctx)}/output`, this._tracer));
                    if (exportError) {
                        (0, index_js_2.recordSpanException)(span, exportError);
                        await this.#cleanupAndWaitUntil(payload, ctx, initOutput, signal);
                        return this.#internalErrorResult(execution, index_js_3.TaskRunErrorCodes.TASK_OUTPUT_ERROR, exportError);
                    }
                    const [attrError, attributes] = await (0, tryCatch_js_1.tryCatch)((0, ioSerialization_js_1.createPacketAttributes)(finalOutput, semanticInternalAttributes_js_1.SemanticInternalAttributes.OUTPUT, semanticInternalAttributes_js_1.SemanticInternalAttributes.OUTPUT_TYPE));
                    if (!attrError && attributes) {
                        span.setAttributes(attributes);
                    }
                    await this.#callOnSuccessFunctions(payload, output, ctx, initOutput, signal);
                    await this.#callOnCompleteFunctions(payload, { ok: true, data: output }, ctx, initOutput, signal);
                    await this.#cleanupAndWaitUntil(payload, ctx, initOutput, signal);
                    return {
                        ok: true,
                        id: execution.run.id,
                        output: finalOutput.data,
                        outputType: finalOutput.dataType,
                    };
                };
                const globalMiddlewareHooks = index_js_1.lifecycleHooks.getGlobalMiddlewareHooks();
                const taskMiddlewareHook = index_js_1.lifecycleHooks.getTaskMiddlewareHook(this.task.id);
                const middlewareHooks = [
                    ...globalMiddlewareHooks,
                    taskMiddlewareHook ? { id: this.task.id, fn: taskMiddlewareHook } : undefined,
                ].filter(Boolean);
                return await this.#executeTaskWithMiddlewareHooks(parsedPayload, ctx, execution, middlewareHooks, executeTask, signal);
            });
        }, {
            kind: api_1.SpanKind.CONSUMER,
            attributes: {
                [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "attempt",
                [semanticInternalAttributes_js_1.SemanticInternalAttributes.ENTITY_TYPE]: "attempt",
                [semanticInternalAttributes_js_1.SemanticInternalAttributes.SPAN_ATTEMPT]: true,
                ...(execution.attempt.number === 1
                    ? run_timeline_metrics_api_js_1.runTimelineMetrics.convertMetricsToSpanAttributes()
                    : {}),
                [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_VARIANT]: this._isWarmStart
                    ? index_js_3.WARM_VARIANT
                    : index_js_3.COLD_VARIANT,
                ...(typeof this._executionCount === "number"
                    ? {
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.ATTEMPT_EXECUTION_COUNT]: this._executionCount,
                    }
                    : {}),
            },
            events: execution.attempt.number === 1
                ? run_timeline_metrics_api_js_1.runTimelineMetrics.convertMetricsToSpanEvents()
                : undefined,
        }, index_js_1.traceContext.extractContext(), signal);
        return { result };
    }
    async #executeTaskWithMiddlewareHooks(payload, ctx, execution, hooks, executeTask, signal) {
        let output;
        let executeError;
        const runner = hooks.reduceRight((next, hook) => {
            return async () => {
                await this._tracer.startActiveSpan("middleware()", async (span) => {
                    await hook.fn({ payload, ctx, signal, task: this.task.id, next });
                }, {
                    attributes: {
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "task-middleware",
                        ...this.#lifecycleHookAccessoryAttributes(hook.name),
                    },
                });
            };
        }, async () => {
            const [error, result] = await (0, tryCatch_js_1.tryCatch)(executeTask(payload));
            if (error) {
                executeError = error;
            }
            else {
                output = result;
            }
        });
        const [runnerError] = await (0, tryCatch_js_1.tryCatch)(runner());
        if (runnerError) {
            return this.#internalErrorResult(execution, index_js_3.TaskRunErrorCodes.TASK_MIDDLEWARE_ERROR, runnerError);
        }
        if (executeError) {
            throw executeError;
        }
        return output;
    }
    async #callRun(payload, ctx, init, signal) {
        const runFn = this.task.fns.run;
        if (!runFn) {
            throw new Error("Task does not have a run function");
        }
        // Create a promise that rejects when the signal aborts
        const abortPromise = new Promise((_, reject) => {
            signal.addEventListener("abort", () => {
                if (typeof signal.reason === "string" && signal.reason.includes("cancel")) {
                    return;
                }
                const maxDuration = ctx.run.maxDuration;
                reject(new errors_js_1.InternalError({
                    code: index_js_3.TaskRunErrorCodes.MAX_DURATION_EXCEEDED,
                    message: `Run exceeded maximum compute time (maxDuration) of ${maxDuration} seconds`,
                }));
            });
        });
        return run_timeline_metrics_api_js_1.runTimelineMetrics.measureMetric("trigger.dev/execution", "run", async () => {
            return await this._tracer.startActiveSpan("run()", async (span) => {
                // Race between the run function and the abort promise
                return await Promise.race([runFn(payload, { ctx, init, signal }), abortPromise]);
            }, {
                attributes: { [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "task-fn-run" },
            });
        });
    }
    async #callOnWaitFunctions(wait, payload, ctx, initOutput, signal) {
        const globalWaitHooks = index_js_1.lifecycleHooks.getGlobalWaitHooks();
        const taskWaitHook = index_js_1.lifecycleHooks.getTaskWaitHook(this.task.id);
        if (globalWaitHooks.length === 0 && !taskWaitHook) {
            return;
        }
        const result = await run_timeline_metrics_api_js_1.runTimelineMetrics.measureMetric("trigger.dev/execution", "onWait", async () => {
            for (const hook of globalWaitHooks) {
                const [hookError] = await (0, tryCatch_js_1.tryCatch)(this._tracer.startActiveSpan("onWait()", async (span) => {
                    await hook.fn({ payload, ctx, signal, task: this.task.id, wait, init: initOutput });
                }, {
                    attributes: {
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "task-hook-onWait",
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.COLLAPSED]: true,
                        ...this.#lifecycleHookAccessoryAttributes(hook.name),
                    },
                }));
                if (hookError) {
                    throw hookError;
                }
            }
            if (taskWaitHook) {
                const [hookError] = await (0, tryCatch_js_1.tryCatch)(this._tracer.startActiveSpan("onWait()", async (span) => {
                    await taskWaitHook({
                        payload,
                        ctx,
                        signal,
                        task: this.task.id,
                        wait,
                        init: initOutput,
                    });
                }, {
                    attributes: {
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "task-hook-onWait",
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.COLLAPSED]: true,
                        ...this.#lifecycleHookAccessoryAttributes("task"),
                    },
                }));
                if (hookError) {
                    throw hookError;
                }
            }
        });
    }
    async #callOnCancelFunctions(runPromise, payload, ctx, initOutput, signal, attemptContext) {
        const globalCancelHooks = index_js_1.lifecycleHooks.getGlobalCancelHooks();
        const taskCancelHook = index_js_1.lifecycleHooks.getTaskCancelHook(this.task.id);
        if (globalCancelHooks.length === 0 && !taskCancelHook) {
            return;
        }
        const result = await run_timeline_metrics_api_js_1.runTimelineMetrics.measureMetric("trigger.dev/execution", "onCancel", async () => {
            for (const hook of globalCancelHooks) {
                const [hookError] = await (0, tryCatch_js_1.tryCatch)(this._tracer.startActiveSpan("onCancel()", async (span) => {
                    await hook.fn({
                        payload,
                        ctx,
                        signal,
                        task: this.task.id,
                        init: initOutput,
                        runPromise,
                    });
                }, {
                    attributes: {
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "task-hook-onCancel",
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.COLLAPSED]: true,
                        ...this.#lifecycleHookAccessoryAttributes(hook.name),
                    },
                }, attemptContext));
                if (hookError) {
                    throw hookError;
                }
            }
            if (taskCancelHook) {
                const [hookError] = await (0, tryCatch_js_1.tryCatch)(this._tracer.startActiveSpan("onCancel()", async (span) => {
                    await taskCancelHook({
                        payload,
                        ctx,
                        signal,
                        task: this.task.id,
                        init: initOutput,
                        runPromise,
                    });
                }, {
                    attributes: {
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "task-hook-onCancel",
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.COLLAPSED]: true,
                        ...this.#lifecycleHookAccessoryAttributes("task"),
                    },
                }, attemptContext));
                if (hookError) {
                    throw hookError;
                }
            }
        });
    }
    async #callOnResumeFunctions(wait, payload, ctx, initOutput, signal) {
        const globalResumeHooks = index_js_1.lifecycleHooks.getGlobalResumeHooks();
        const taskResumeHook = index_js_1.lifecycleHooks.getTaskResumeHook(this.task.id);
        if (globalResumeHooks.length === 0 && !taskResumeHook) {
            return;
        }
        const result = await run_timeline_metrics_api_js_1.runTimelineMetrics.measureMetric("trigger.dev/execution", "onResume", async () => {
            for (const hook of globalResumeHooks) {
                const [hookError] = await (0, tryCatch_js_1.tryCatch)(this._tracer.startActiveSpan("onResume()", async (span) => {
                    await hook.fn({ payload, ctx, signal, task: this.task.id, wait, init: initOutput });
                }, {
                    attributes: {
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "task-hook-onResume",
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.COLLAPSED]: true,
                        ...this.#lifecycleHookAccessoryAttributes(hook.name),
                    },
                }));
                if (hookError) {
                    throw hookError;
                }
            }
            if (taskResumeHook) {
                const [hookError] = await (0, tryCatch_js_1.tryCatch)(this._tracer.startActiveSpan("onResume()", async (span) => {
                    await taskResumeHook({
                        payload,
                        ctx,
                        signal,
                        task: this.task.id,
                        wait,
                        init: initOutput,
                    });
                }, {
                    attributes: {
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "task-hook-onResume",
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.COLLAPSED]: true,
                        ...this.#lifecycleHookAccessoryAttributes("task"),
                    },
                }));
                if (hookError) {
                    throw hookError;
                }
            }
        });
    }
    async #callInitFunctions(payload, ctx, signal) {
        const globalInitHooks = index_js_1.lifecycleHooks.getGlobalInitHooks();
        const taskInitHook = index_js_1.lifecycleHooks.getTaskInitHook(this.task.id);
        if (globalInitHooks.length === 0 && !taskInitHook) {
            return {};
        }
        const result = await run_timeline_metrics_api_js_1.runTimelineMetrics.measureMetric("trigger.dev/execution", "init", async () => {
            // Store global hook results in an array
            const globalResults = [];
            for (const hook of globalInitHooks) {
                const [hookError, result] = await (0, tryCatch_js_1.tryCatch)(this._tracer.startActiveSpan("init()", async (span) => {
                    const result = await hook.fn({ payload, ctx, signal, task: this.task.id });
                    if (result && typeof result === "object" && !Array.isArray(result)) {
                        span.setAttributes((0, index_js_1.flattenAttributes)(result, undefined, index_js_1.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT));
                        return result;
                    }
                    return {};
                }, {
                    attributes: {
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "task-hook-init",
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.COLLAPSED]: true,
                        ...this.#lifecycleHookAccessoryAttributes(hook.name),
                    },
                }));
                if (hookError) {
                    throw hookError;
                }
                if (result && typeof result === "object" && !Array.isArray(result)) {
                    globalResults.push(result);
                }
            }
            // Merge all global results into a single object
            const mergedGlobalResults = Object.assign({}, ...globalResults);
            if (taskInitHook) {
                const [hookError, taskResult] = await (0, tryCatch_js_1.tryCatch)(this._tracer.startActiveSpan("init()", async (span) => {
                    const result = await taskInitHook({ payload, ctx, signal, task: this.task.id });
                    if (result && typeof result === "object" && !Array.isArray(result)) {
                        span.setAttributes((0, index_js_1.flattenAttributes)(result, undefined, index_js_1.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT));
                        return result;
                    }
                    return {};
                }, {
                    attributes: {
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "task-hook-init",
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.COLLAPSED]: true,
                        ...this.#lifecycleHookAccessoryAttributes("task"),
                    },
                }));
                if (hookError) {
                    throw hookError;
                }
                // Only merge if taskResult is an object
                if (taskResult && typeof taskResult === "object" && !Array.isArray(taskResult)) {
                    return { ...mergedGlobalResults, ...taskResult };
                }
                // If taskResult isn't an object, return global results
                return mergedGlobalResults;
            }
            return mergedGlobalResults;
        });
        if (result && typeof result === "object" && !Array.isArray(result)) {
            return result;
        }
        return;
    }
    async #callOnSuccessFunctions(payload, output, ctx, initOutput, signal) {
        const globalSuccessHooks = index_js_1.lifecycleHooks.getGlobalSuccessHooks();
        const taskSuccessHook = index_js_1.lifecycleHooks.getTaskSuccessHook(this.task.id);
        if (globalSuccessHooks.length === 0 && !taskSuccessHook) {
            return;
        }
        return await run_timeline_metrics_api_js_1.runTimelineMetrics.measureMetric("trigger.dev/execution", "success", async () => {
            for (const hook of globalSuccessHooks) {
                const [hookError] = await (0, tryCatch_js_1.tryCatch)(this._tracer.startActiveSpan("onSuccess()", async (span) => {
                    await hook.fn({
                        payload,
                        output,
                        ctx,
                        signal,
                        task: this.task.id,
                        init: initOutput,
                    });
                }, {
                    attributes: {
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "task-hook-onSuccess",
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.COLLAPSED]: true,
                        ...this.#lifecycleHookAccessoryAttributes(hook.name),
                    },
                }));
                if (hookError) {
                    throw hookError;
                }
            }
            if (taskSuccessHook) {
                const [hookError] = await (0, tryCatch_js_1.tryCatch)(this._tracer.startActiveSpan("onSuccess()", async (span) => {
                    await taskSuccessHook({
                        payload,
                        output,
                        ctx,
                        signal,
                        task: this.task.id,
                        init: initOutput,
                    });
                }, {
                    attributes: {
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "task-hook-onSuccess",
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.COLLAPSED]: true,
                        ...this.#lifecycleHookAccessoryAttributes("task"),
                    },
                }));
                if (hookError) {
                    throw hookError;
                }
            }
        });
    }
    async #callOnFailureFunctions(payload, error, ctx, initOutput, signal) {
        const globalFailureHooks = index_js_1.lifecycleHooks.getGlobalFailureHooks();
        const taskFailureHook = index_js_1.lifecycleHooks.getTaskFailureHook(this.task.id);
        if (globalFailureHooks.length === 0 && !taskFailureHook) {
            return;
        }
        return await run_timeline_metrics_api_js_1.runTimelineMetrics.measureMetric("trigger.dev/execution", "failure", async () => {
            for (const hook of globalFailureHooks) {
                const [hookError] = await (0, tryCatch_js_1.tryCatch)(this._tracer.startActiveSpan("onFailure()", async (span) => {
                    await hook.fn({
                        payload,
                        error,
                        ctx,
                        signal,
                        task: this.task.id,
                        init: initOutput,
                    });
                }, {
                    attributes: {
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "task-hook-onFailure",
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.COLLAPSED]: true,
                        ...this.#lifecycleHookAccessoryAttributes(hook.name),
                    },
                }));
                if (hookError) {
                    throw hookError;
                }
            }
            if (taskFailureHook) {
                const [hookError] = await (0, tryCatch_js_1.tryCatch)(this._tracer.startActiveSpan("onFailure()", async (span) => {
                    await taskFailureHook({
                        payload,
                        error,
                        ctx,
                        signal,
                        task: this.task.id,
                        init: initOutput,
                    });
                }, {
                    attributes: {
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "task-hook-onFailure",
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.COLLAPSED]: true,
                        ...this.#lifecycleHookAccessoryAttributes("task"),
                    },
                }));
                if (hookError) {
                    throw hookError;
                }
            }
        });
    }
    async #parsePayload(payload) {
        if (!this.task.fns.parsePayload) {
            return payload;
        }
        const [parseError, result] = await (0, tryCatch_js_1.tryCatch)(this.task.fns.parsePayload(payload));
        if (parseError) {
            throw new errors_js_1.TaskPayloadParsedError(parseError);
        }
        return result;
    }
    async #callOnStartFunctions(payload, ctx, initOutput, signal) {
        const globalStartHooks = index_js_1.lifecycleHooks.getGlobalStartHooks();
        const taskStartHook = index_js_1.lifecycleHooks.getTaskStartHook(this.task.id);
        if (globalStartHooks.length === 0 && !taskStartHook) {
            return;
        }
        return await run_timeline_metrics_api_js_1.runTimelineMetrics.measureMetric("trigger.dev/execution", "start", async () => {
            for (const hook of globalStartHooks) {
                const [hookError] = await (0, tryCatch_js_1.tryCatch)(this._tracer.startActiveSpan("onStart()", async (span) => {
                    await hook.fn({ payload, ctx, signal, task: this.task.id, init: initOutput });
                }, {
                    attributes: {
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "task-hook-onStart",
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.COLLAPSED]: true,
                        ...this.#lifecycleHookAccessoryAttributes(hook.name),
                    },
                }));
                if (hookError) {
                    throw hookError;
                }
            }
            if (taskStartHook) {
                const [hookError] = await (0, tryCatch_js_1.tryCatch)(this._tracer.startActiveSpan("onStart()", async (span) => {
                    await taskStartHook({
                        payload,
                        ctx,
                        signal,
                        task: this.task.id,
                        init: initOutput,
                    });
                }, {
                    attributes: {
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "task-hook-onStart",
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.COLLAPSED]: true,
                        ...this.#lifecycleHookAccessoryAttributes("task"),
                    },
                }));
                if (hookError) {
                    throw hookError;
                }
            }
        });
    }
    async #cleanupAndWaitUntil(payload, ctx, initOutput, signal) {
        await this.#callCleanupFunctions(payload, ctx, initOutput, signal);
        await this.#blockForWaitUntil();
    }
    async #callCleanupFunctions(payload, ctx, initOutput, signal) {
        const globalCleanupHooks = index_js_1.lifecycleHooks.getGlobalCleanupHooks();
        const taskCleanupHook = index_js_1.lifecycleHooks.getTaskCleanupHook(this.task.id);
        if (globalCleanupHooks.length === 0 && !taskCleanupHook) {
            return;
        }
        return await run_timeline_metrics_api_js_1.runTimelineMetrics.measureMetric("trigger.dev/execution", "cleanup", async () => {
            for (const hook of globalCleanupHooks) {
                const [hookError] = await (0, tryCatch_js_1.tryCatch)(this._tracer.startActiveSpan("cleanup()", async (span) => {
                    await hook.fn({
                        payload,
                        ctx,
                        signal,
                        task: this.task.id,
                        init: initOutput,
                    });
                }, {
                    attributes: {
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "task-hook-cleanup",
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.COLLAPSED]: true,
                        ...this.#lifecycleHookAccessoryAttributes(hook.name),
                    },
                }));
                if (hookError) {
                    throw hookError;
                }
            }
            if (taskCleanupHook) {
                const [hookError] = await (0, tryCatch_js_1.tryCatch)(this._tracer.startActiveSpan("cleanup()", async (span) => {
                    await taskCleanupHook({
                        payload,
                        ctx,
                        signal,
                        task: this.task.id,
                        init: initOutput,
                    });
                }, {
                    attributes: {
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "task-hook-cleanup",
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.COLLAPSED]: true,
                        ...this.#lifecycleHookAccessoryAttributes("task"),
                    },
                }));
                if (hookError) {
                    throw hookError;
                }
            }
        });
    }
    async #blockForWaitUntil() {
        if (!index_js_1.waitUntil.requiresResolving()) {
            return;
        }
        return this._tracer.startActiveSpan("waitUntil", async (span) => {
            return await index_js_1.waitUntil.blockUntilSettled(60_000);
        }, {
            attributes: {
                [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "tabler-clock",
                [semanticInternalAttributes_js_1.SemanticInternalAttributes.COLLAPSED]: true,
            },
        });
    }
    async #handleError(execution, error, payload, ctx, init, signal) {
        const retriesConfig = this._retries;
        const retry = this.task.retry ?? retriesConfig?.default;
        // Early exit conditions that prevent retrying
        if ((0, errors_js_1.isInternalError)(error) && error.skipRetrying) {
            return { status: "skipped", error };
        }
        if (error instanceof Error &&
            (error.name === "AbortTaskRunError" || error.name === "TaskPayloadParsedError")) {
            return { status: "skipped" };
        }
        // Check for unretryable API errors (client errors except 408 and 429)
        if (error instanceof Error &&
            error.name === "TriggerApiError" &&
            "status" in error &&
            typeof error.status === "number") {
            const status = error.status;
            if (status && status >= 400 && status < 500 && status !== 408 && status !== 429) {
                return { status: "skipped", error };
            }
        }
        // Calculate default retry delay if retry config exists
        let defaultDelay;
        if (retry) {
            if (execution.run.maxAttempts) {
                retry.maxAttempts = Math.max(execution.run.maxAttempts, 1);
            }
            defaultDelay = (0, retries_js_1.calculateNextRetryDelay)(retry, execution.attempt.number);
            // Handle rate limit errors
            if (defaultDelay &&
                error instanceof Error &&
                error.name === "TriggerApiError" &&
                error.status === 429) {
                const rateLimitError = error;
                const rateLimitDelay = rateLimitError.millisecondsUntilReset;
                if (rateLimitDelay) {
                    defaultDelay = rateLimitDelay;
                }
            }
        }
        const defaultRetryResult = typeof defaultDelay === "undefined"
            ? { status: "noop" }
            : {
                status: "retry",
                retry: { timestamp: Date.now() + defaultDelay, delay: defaultDelay },
            };
        // Check if retries are enabled in dev environment
        if (execution.environment.type === "DEVELOPMENT" &&
            typeof retriesConfig?.enabledInDev === "boolean" &&
            !retriesConfig.enabledInDev) {
            return { status: "skipped" };
        }
        const taskCatchErrorHook = index_js_1.lifecycleHooks.getTaskCatchErrorHook(this.task.id);
        const globalCatchErrorHooks = index_js_1.lifecycleHooks.getGlobalCatchErrorHooks();
        if (globalCatchErrorHooks.length === 0 && !taskCatchErrorHook) {
            return defaultRetryResult;
        }
        return this._tracer.startActiveSpan("catchError", async (span) => {
            // Try task-specific catch error hook first
            if (taskCatchErrorHook) {
                const result = await taskCatchErrorHook({
                    payload,
                    error,
                    ctx,
                    init,
                    retry,
                    retryDelayInMs: defaultDelay,
                    retryAt: defaultDelay ? new Date(Date.now() + defaultDelay) : undefined,
                    signal,
                    task: this.task.id,
                });
                if (result) {
                    return this.#processHandleErrorResult(result, execution.attempt.number, defaultDelay);
                }
            }
            // Try global catch error hooks in order
            for (const hook of globalCatchErrorHooks) {
                const result = await hook.fn({
                    payload,
                    error,
                    ctx,
                    init,
                    retry,
                    retryDelayInMs: defaultDelay,
                    retryAt: defaultDelay ? new Date(Date.now() + defaultDelay) : undefined,
                    signal,
                    task: this.task.id,
                });
                if (result) {
                    return this.#processHandleErrorResult(result, execution.attempt.number, defaultDelay);
                }
            }
            // If no hooks handled the error, use default retry behavior
            return defaultRetryResult;
        }, {
            attributes: {
                [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "task-hook-catchError",
                [semanticInternalAttributes_js_1.SemanticInternalAttributes.COLLAPSED]: true,
            },
        });
    }
    // Helper method to process handle error results
    #processHandleErrorResult(result, attemptNumber, defaultDelay) {
        if (result.skipRetrying) {
            return { status: "skipped", error: result.error };
        }
        if (typeof result.retryAt !== "undefined") {
            return {
                status: "retry",
                retry: {
                    timestamp: result.retryAt.getTime(),
                    delay: result.retryAt.getTime() - Date.now(),
                },
                error: result.error,
            };
        }
        if (typeof result.retryDelayInMs === "number") {
            return {
                status: "retry",
                retry: {
                    timestamp: Date.now() + result.retryDelayInMs,
                    delay: result.retryDelayInMs,
                },
                error: result.error,
            };
        }
        if (result.retry && typeof result.retry === "object") {
            const delay = (0, retries_js_1.calculateNextRetryDelay)(result.retry, attemptNumber);
            return typeof delay === "undefined"
                ? { status: "noop", error: result.error }
                : {
                    status: "retry",
                    retry: { timestamp: Date.now() + delay, delay },
                    error: result.error,
                };
        }
        return { status: "noop", error: result.error };
    }
    async #callOnCompleteFunctions(payload, result, ctx, initOutput, signal) {
        const globalCompleteHooks = index_js_1.lifecycleHooks.getGlobalCompleteHooks();
        const taskCompleteHook = index_js_1.lifecycleHooks.getTaskCompleteHook(this.task.id);
        if (globalCompleteHooks.length === 0 && !taskCompleteHook) {
            return;
        }
        return await run_timeline_metrics_api_js_1.runTimelineMetrics.measureMetric("trigger.dev/execution", "complete", async () => {
            for (const hook of globalCompleteHooks) {
                const [hookError] = await (0, tryCatch_js_1.tryCatch)(this._tracer.startActiveSpan("onComplete()", async (span) => {
                    await hook.fn({
                        payload,
                        result,
                        ctx,
                        signal,
                        task: this.task.id,
                        init: initOutput,
                    });
                }, {
                    attributes: {
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "task-hook-onComplete",
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.COLLAPSED]: true,
                        ...this.#lifecycleHookAccessoryAttributes(hook.name),
                    },
                }));
                if (hookError) {
                    throw hookError;
                }
            }
            if (taskCompleteHook) {
                const [hookError] = await (0, tryCatch_js_1.tryCatch)(this._tracer.startActiveSpan("onComplete()", async (span) => {
                    await taskCompleteHook({
                        payload,
                        result,
                        ctx,
                        signal,
                        task: this.task.id,
                        init: initOutput,
                    });
                }, {
                    attributes: {
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "task-hook-onComplete",
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.COLLAPSED]: true,
                        ...this.#lifecycleHookAccessoryAttributes("task"),
                    },
                }));
                if (hookError) {
                    throw hookError;
                }
            }
        });
    }
    #internalErrorResult(execution, code, error, skippedRetrying) {
        return {
            ok: false,
            id: execution.run.id,
            error: {
                type: "INTERNAL_ERROR",
                code,
                message: error instanceof Error
                    ? `${error.name}: ${error.message}`
                    : typeof error === "string"
                        ? error
                        : undefined,
                stackTrace: error instanceof Error ? error.stack : undefined,
            },
            skippedRetrying,
        };
    }
    #lifecycleHookAccessoryAttributes(name) {
        return (0, index_js_1.accessoryAttributes)({
            items: [
                {
                    text: name ?? "global",
                    variant: "normal",
                },
            ],
            style: "codepath",
        });
    }
}
exports.TaskExecutor = TaskExecutor;
//# sourceMappingURL=taskExecutor.js.map