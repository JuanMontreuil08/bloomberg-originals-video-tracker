"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WarmStartClient = void 0;
const runEngine_js_1 = require("../schemas/runEngine.js");
const structuredLogger_js_1 = require("../utils/structuredLogger.js");
const warmStart_js_1 = require("../schemas/warmStart.js");
const zodfetch_js_1 = require("../zodfetch.js");
const backoff_js_1 = require("../apps/backoff.js");
class WarmStartClient {
    opts;
    logger = new structuredLogger_js_1.SimpleStructuredLogger("warm-start-client");
    apiUrl;
    backoff = new backoff_js_1.ExponentialBackoff("FullJitter");
    get connectUrl() {
        return new URL("/connect", this.apiUrl);
    }
    get warmStartUrl() {
        return new URL("/warm-start", this.apiUrl);
    }
    constructor(opts) {
        this.opts = opts;
        this.apiUrl = opts.apiUrl;
    }
    async connect() {
        return (0, zodfetch_js_1.wrapZodFetch)(warmStart_js_1.WarmStartConnectResponse, this.connectUrl.href, {
            method: "GET",
            headers: {
                "Content-Type": "application/json",
            },
        }, {
            retry: {
                minTimeoutInMs: 200,
                maxTimeoutInMs: 2000,
                maxAttempts: 3,
                factor: 2,
                randomize: false,
            },
        });
    }
    async warmStart({ workerInstanceName, connectionTimeoutMs, keepaliveMs, }) {
        const res = await this.longPoll(this.warmStartUrl.href, {
            method: "GET",
            headers: {
                "x-trigger-workload-controller-id": this.opts.controllerId,
                "x-trigger-deployment-id": this.opts.deploymentId,
                "x-trigger-deployment-version": this.opts.deploymentVersion,
                "x-trigger-machine-cpu": this.opts.machineCpu,
                "x-trigger-machine-memory": this.opts.machineMemory,
                "x-trigger-worker-instance-name": workerInstanceName,
            },
        }, {
            timeoutMs: connectionTimeoutMs,
            totalDurationMs: keepaliveMs,
        });
        if (!res.ok) {
            this.logger.error("warmStart: failed", {
                error: res.error,
                connectionTimeoutMs,
                keepaliveMs,
            });
            return null;
        }
        const nextRun = runEngine_js_1.DequeuedMessage.parse(res.data);
        this.logger.debug("warmStart: got next run", { nextRun });
        return nextRun;
    }
    async longPoll(url, requestInit, { timeoutMs, totalDurationMs, }) {
        this.logger.debug("Long polling", { url, requestInit, timeoutMs, totalDurationMs });
        const endTime = Date.now() + totalDurationMs;
        let retries = 0;
        while (Date.now() < endTime) {
            try {
                const controller = new AbortController();
                const signal = controller.signal;
                const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
                const response = await fetch(url, { ...requestInit, signal });
                clearTimeout(timeoutId);
                if (response.ok) {
                    const data = await response.json();
                    return {
                        ok: true,
                        data,
                    };
                }
                else {
                    return {
                        ok: false,
                        error: `Server error: ${response.status}`,
                    };
                }
            }
            catch (error) {
                if (error instanceof Error && error.name === "AbortError") {
                    this.logger.log("Long poll request timed out, retrying...");
                    continue;
                }
                else {
                    this.logger.error("Error during fetch, retrying...", { error });
                    // Wait with exponential backoff
                    await this.backoff.wait(retries++);
                    continue;
                }
            }
        }
        return {
            ok: false,
            error: "TotalDurationExceeded",
        };
    }
}
exports.WarmStartClient = WarmStartClient;
//# sourceMappingURL=warmStartClient.js.map