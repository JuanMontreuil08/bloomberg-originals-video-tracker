import { DeserializedJson } from "../../schemas/json.js";
import { RunStatus, SubscribeRunRawShape } from "../schemas/api.js";
import { SerializedError } from "../schemas/common.js";
import { AnyRunTypes, AnyTask, InferRunTypes } from "../types/tasks.js";
import { ApiClient } from "./index.js";
import { AsyncIterableStream } from "../streams/asyncIterableStream.js";
export type RunShape<TRunTypes extends AnyRunTypes> = TRunTypes extends AnyRunTypes ? {
    id: string;
    taskIdentifier: TRunTypes["taskIdentifier"];
    payload: TRunTypes["payload"];
    output?: TRunTypes["output"];
    createdAt: Date;
    updatedAt: Date;
    status: RunStatus;
    durationMs: number;
    costInCents: number;
    baseCostInCents: number;
    tags: string[];
    idempotencyKey?: string;
    expiredAt?: Date;
    ttl?: string;
    finishedAt?: Date;
    startedAt?: Date;
    delayedUntil?: Date;
    queuedAt?: Date;
    metadata?: Record<string, DeserializedJson>;
    error?: SerializedError;
    isTest: boolean;
    isQueued: boolean;
    isExecuting: boolean;
    isWaiting: boolean;
    isCompleted: boolean;
    isFailed: boolean;
    isSuccess: boolean;
    isCancelled: boolean;
} : never;
export type AnyRunShape = RunShape<AnyRunTypes>;
export type TaskRunShape<TTask extends AnyTask> = RunShape<InferRunTypes<TTask>>;
export type RealtimeRun<TTask extends AnyTask> = TaskRunShape<TTask>;
export type AnyRealtimeRun = RealtimeRun<AnyTask>;
export type RealtimeRunSkipColumns = Array<"startedAt" | "delayUntil" | "queuedAt" | "expiredAt" | "completedAt" | "number" | "isTest" | "usageDurationMs" | "costInCents" | "baseCostInCents" | "ttl" | "payload" | "payloadType" | "metadata" | "output" | "outputType" | "runTags" | "error">;
export type RunStreamCallback<TRunTypes extends AnyRunTypes> = (run: RunShape<TRunTypes>) => void | Promise<void>;
export type RunShapeStreamOptions = {
    headers?: Record<string, string>;
    fetchClient?: typeof fetch;
    closeOnComplete?: boolean;
    signal?: AbortSignal;
    client?: ApiClient;
    onFetchError?: (e: Error) => void;
};
export type StreamPartResult<TRun, TStreams extends Record<string, any>> = {
    [K in keyof TStreams]: {
        type: K;
        chunk: TStreams[K];
        run: TRun;
    };
}[keyof TStreams];
export type RunWithStreamsResult<TRun, TStreams extends Record<string, any>> = {
    type: "run";
    run: TRun;
} | StreamPartResult<TRun, TStreams>;
export declare function runShapeStream<TRunTypes extends AnyRunTypes>(url: string, options?: RunShapeStreamOptions): RunSubscription<TRunTypes>;
export interface StreamSubscription {
    subscribe(): Promise<ReadableStream<unknown>>;
}
export interface StreamSubscriptionFactory {
    createSubscription(runId: string, streamKey: string, baseUrl?: string): StreamSubscription;
}
export declare class SSEStreamSubscription implements StreamSubscription {
    private url;
    private options;
    constructor(url: string, options: {
        headers?: Record<string, string>;
        signal?: AbortSignal;
    });
    subscribe(): Promise<ReadableStream<unknown>>;
}
export declare class SSEStreamSubscriptionFactory implements StreamSubscriptionFactory {
    private baseUrl;
    private options;
    constructor(baseUrl: string, options: {
        headers?: Record<string, string>;
        signal?: AbortSignal;
    });
    createSubscription(runId: string, streamKey: string, baseUrl?: string): StreamSubscription;
}
export declare class ElectricStreamSubscription implements StreamSubscription {
    private url;
    private options;
    constructor(url: string, options: {
        headers?: Record<string, string>;
        signal?: AbortSignal;
    });
    subscribe(): Promise<ReadableStream<unknown>>;
}
export interface RunShapeProvider {
    onShape(callback: (shape: SubscribeRunRawShape) => Promise<void>): Promise<() => void>;
}
export type RunSubscriptionOptions = RunShapeStreamOptions & {
    runShapeStream: ReadableStream<SubscribeRunRawShape>;
    stopRunShapeStream: () => void;
    streamFactory: StreamSubscriptionFactory;
    abortController: AbortController;
};
export declare class RunSubscription<TRunTypes extends AnyRunTypes> {
    private options;
    private stream;
    private packetCache;
    private _closeOnComplete;
    private _isRunComplete;
    constructor(options: RunSubscriptionOptions);
    unsubscribe(): void;
    [Symbol.asyncIterator](): AsyncIterator<RunShape<TRunTypes>>;
    getReader(): ReadableStreamDefaultReader<RunShape<TRunTypes>>;
    withStreams<TStreams extends Record<string, any>>(): AsyncIterableStream<RunWithStreamsResult<RunShape<TRunTypes>, TStreams>>;
    private transformRunShape;
}
