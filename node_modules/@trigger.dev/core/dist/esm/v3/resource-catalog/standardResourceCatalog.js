export class StandardResourceCatalog {
    _taskSchemas = new Map();
    _taskMetadata = new Map();
    _taskFunctions = new Map();
    _taskFileMetadata = new Map();
    _currentFileContext;
    _queueMetadata = new Map();
    setCurrentFileContext(filePath, entryPoint) {
        this._currentFileContext = { filePath, entryPoint };
    }
    clearCurrentFileContext() {
        this._currentFileContext = undefined;
    }
    registerQueueMetadata(queue) {
        const existingQueue = this._queueMetadata.get(queue.name);
        //if it exists already AND concurrencyLimit is different, log a warning
        if (existingQueue) {
            const isConcurrencyLimitDifferent = existingQueue.concurrencyLimit !== queue.concurrencyLimit;
            if (isConcurrencyLimitDifferent) {
                let message = `Queue "${queue.name}" is defined twice, with different settings.`;
                if (isConcurrencyLimitDifferent) {
                    message += `\n        - concurrencyLimit: ${existingQueue.concurrencyLimit} vs ${queue.concurrencyLimit}`;
                }
                message += "\n       Keeping the first definition:";
                message += `\n        - concurrencyLimit: ${existingQueue.concurrencyLimit}`;
                console.warn(message);
                return;
            }
        }
        this._queueMetadata.set(queue.name, queue);
    }
    registerWorkerManifest(workerManifest) {
        for (const task of workerManifest.tasks) {
            this._taskFileMetadata.set(task.id, {
                filePath: task.filePath,
                entryPoint: task.entryPoint,
            });
        }
    }
    registerTaskMetadata(task) {
        if (!this._currentFileContext) {
            return;
        }
        const { fns, schema, ...metadata } = task;
        if (!task.id) {
            return;
        }
        this._taskFileMetadata.set(task.id, {
            ...this._currentFileContext,
        });
        this._taskMetadata.set(task.id, metadata);
        this._taskFunctions.set(task.id, fns);
        if (schema) {
            this._taskSchemas.set(task.id, schema);
        }
    }
    updateTaskMetadata(id, updates) {
        const existingMetadata = this._taskMetadata.get(id);
        if (existingMetadata) {
            this._taskMetadata.set(id, {
                ...existingMetadata,
                ...updates,
            });
        }
        if (updates.fns) {
            const existingFunctions = this._taskFunctions.get(id);
            if (existingFunctions) {
                this._taskFunctions.set(id, {
                    ...existingFunctions,
                    ...updates.fns,
                });
            }
        }
    }
    // Return all the tasks, without the functions
    listTaskManifests() {
        const result = [];
        for (const [id, metadata] of this._taskMetadata) {
            const fileMetadata = this._taskFileMetadata.get(id);
            if (!fileMetadata) {
                continue;
            }
            const taskManifest = {
                ...metadata,
                ...fileMetadata,
            };
            result.push(taskManifest);
        }
        return result;
    }
    getTaskSchema(id) {
        return this._taskSchemas.get(id);
    }
    listQueueManifests() {
        return Array.from(this._queueMetadata.values());
    }
    getTaskManifest(id) {
        const metadata = this._taskMetadata.get(id);
        const fileMetadata = this._taskFileMetadata.get(id);
        if (!metadata || !fileMetadata) {
            return undefined;
        }
        return {
            ...metadata,
            ...fileMetadata,
        };
    }
    getTask(id) {
        const metadata = this._taskMetadata.get(id);
        const fileMetadata = this._taskFileMetadata.get(id);
        const fns = this._taskFunctions.get(id);
        if (!metadata || !fns || !fileMetadata) {
            return undefined;
        }
        return {
            ...metadata,
            ...fileMetadata,
            fns,
        };
    }
    taskExists(id) {
        return this._taskMetadata.has(id);
    }
    disable() {
        // noop
    }
}
//# sourceMappingURL=standardResourceCatalog.js.map