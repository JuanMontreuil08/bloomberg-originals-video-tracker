import { request as httpsRequest } from "node:https";
import { request as httpRequest } from "node:http";
import { URL } from "node:url";
export class MetadataStream {
    options;
    controller = new AbortController();
    serverStream;
    consumerStream;
    streamPromise;
    retryCount = 0;
    maxRetries;
    currentChunkIndex = 0;
    constructor(options) {
        this.options = options;
        const [serverStream, consumerStream] = this.createTeeStreams();
        this.serverStream = serverStream;
        this.consumerStream = consumerStream;
        this.maxRetries = options.maxRetries ?? 10;
        this.streamPromise = this.initializeServerStream();
    }
    createTeeStreams() {
        const readableSource = new ReadableStream({
            start: async (controller) => {
                try {
                    for await (const value of this.options.source) {
                        controller.enqueue(value);
                    }
                    controller.close();
                }
                catch (error) {
                    controller.error(error);
                }
            },
        });
        return readableSource.tee();
    }
    async makeRequest(startFromChunk = 0) {
        const reader = this.serverStream.getReader();
        return new Promise((resolve, reject) => {
            const url = new URL(this.buildUrl());
            const timeout = 15 * 60 * 1000; // 15 minutes
            const requestFn = url.protocol === "https:" ? httpsRequest : httpRequest;
            const req = requestFn({
                method: "POST",
                hostname: url.hostname,
                port: url.port || (url.protocol === "https:" ? 443 : 80),
                path: url.pathname + url.search,
                headers: {
                    ...this.options.headers,
                    "Content-Type": "application/json",
                    "X-Resume-From-Chunk": startFromChunk.toString(),
                },
                timeout,
            });
            req.on("error", (error) => {
                safeReleaseLock(reader);
                reject(error);
            });
            req.on("timeout", () => {
                safeReleaseLock(reader);
                req.destroy(new Error("Request timed out"));
            });
            req.on("response", (res) => {
                if (res.statusCode === 408) {
                    safeReleaseLock(reader);
                    if (this.retryCount < this.maxRetries) {
                        this.retryCount++;
                        resolve(this.makeRequest(this.currentChunkIndex));
                        return;
                    }
                    reject(new Error(`Max retries (${this.maxRetries}) exceeded after timeout`));
                    return;
                }
                if (res.statusCode && (res.statusCode < 200 || res.statusCode >= 300)) {
                    const error = new Error(`HTTP error! status: ${res.statusCode}`);
                    reject(error);
                    return;
                }
                res.on("end", () => {
                    resolve();
                });
                res.resume();
            });
            if (this.options.signal) {
                this.options.signal.addEventListener("abort", () => {
                    req.destroy(new Error("Request aborted"));
                });
            }
            const processStream = async () => {
                try {
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) {
                            req.end();
                            break;
                        }
                        const stringified = JSON.stringify(value) + "\n";
                        req.write(stringified);
                        this.currentChunkIndex++;
                    }
                }
                catch (error) {
                    reject(error);
                }
            };
            processStream().catch((error) => {
                reject(error);
            });
        });
    }
    async initializeServerStream() {
        await this.makeRequest(0);
    }
    async wait() {
        return this.streamPromise;
    }
    [Symbol.asyncIterator]() {
        return streamToAsyncIterator(this.consumerStream);
    }
    buildUrl() {
        switch (this.options.version ?? "v1") {
            case "v1": {
                return `${this.options.baseUrl}/realtime/v1/streams/${this.options.runId}/${this.options.target ?? "self"}/${this.options.key}`;
            }
            case "v2": {
                return `${this.options.baseUrl}/realtime/v2/streams/${this.options.runId}/${this.options.key}`;
            }
        }
    }
}
async function* streamToAsyncIterator(stream) {
    const reader = stream.getReader();
    try {
        while (true) {
            const { done, value } = await reader.read();
            if (done)
                return;
            yield value;
        }
    }
    finally {
        safeReleaseLock(reader);
    }
}
function safeReleaseLock(reader) {
    try {
        reader.releaseLock();
    }
    catch (error) { }
}
//# sourceMappingURL=metadataStream.js.map