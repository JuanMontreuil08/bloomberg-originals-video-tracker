import { z } from "zod";
import { DeserializedJsonSchema } from "../../schemas/json.js";
import { FlushedRunMetadata, GitMeta, MachinePresetName, SerializedError, TaskRunError, } from "./common.js";
import { BackgroundWorkerMetadata } from "./resources.js";
import { DequeuedMessage, MachineResources } from "./runEngine.js";
export const RunEngineVersion = z.union([z.literal("V1"), z.literal("V2")]);
export const WhoAmIResponseSchema = z.object({
    userId: z.string(),
    email: z.string().email(),
    dashboardUrl: z.string(),
    project: z
        .object({
        name: z.string(),
        url: z.string(),
        orgTitle: z.string(),
    })
        .optional(),
});
export const GetProjectResponseBody = z.object({
    id: z.string(),
    externalRef: z.string(),
    name: z.string(),
    slug: z.string(),
    createdAt: z.coerce.date(),
    organization: z.object({
        id: z.string(),
        title: z.string(),
        slug: z.string(),
        createdAt: z.coerce.date(),
    }),
});
export const GetProjectsResponseBody = z.array(GetProjectResponseBody);
export const GetProjectEnvResponse = z.object({
    apiKey: z.string(),
    name: z.string(),
    apiUrl: z.string(),
    projectId: z.string(),
});
export const CreateBackgroundWorkerRequestBody = z.object({
    localOnly: z.boolean(),
    metadata: BackgroundWorkerMetadata,
    engine: RunEngineVersion.optional(),
    supportsLazyAttempts: z.boolean().optional(),
    buildPlatform: z.string().optional(),
    targetPlatform: z.string().optional(),
});
export const CreateBackgroundWorkerResponse = z.object({
    id: z.string(),
    version: z.string(),
    contentHash: z.string(),
});
//an array of 1, 2, or 3 strings
const RunTag = z.string().max(128, "Tags must be less than 128 characters");
export const RunTags = z.union([RunTag, RunTag.array()]);
export const TriggerTaskRequestBody = z.object({
    payload: z.any(),
    context: z.any(),
    options: z
        .object({
        /** @deprecated engine v1 only */
        dependentAttempt: z.string().optional(),
        /** @deprecated engine v1 only */
        parentAttempt: z.string().optional(),
        /** @deprecated engine v1 only */
        dependentBatch: z.string().optional(),
        /**
         * If triggered in a batch, this is the BatchTaskRun id
         */
        parentBatch: z.string().optional(),
        /**
         * RunEngine v2
         * If triggered inside another run, the parentRunId is the friendly ID of the parent run.
         */
        parentRunId: z.string().optional(),
        /**
         * RunEngine v2
         * Should be `true` if `triggerAndWait` or `batchTriggerAndWait`
         */
        resumeParentOnCompletion: z.boolean().optional(),
        /**
         * Locks the version to the passed value.
         * Automatically set when using `triggerAndWait` or `batchTriggerAndWait`
         */
        lockToVersion: z.string().optional(),
        queue: z
            .object({
            name: z.string(),
            // @deprecated, this is now specified on the queue
            concurrencyLimit: z.number().int().optional(),
        })
            .optional(),
        concurrencyKey: z.string().optional(),
        delay: z.string().or(z.coerce.date()).optional(),
        idempotencyKey: z.string().optional(),
        idempotencyKeyTTL: z.string().optional(),
        machine: MachinePresetName.optional(),
        maxAttempts: z.number().int().optional(),
        maxDuration: z.number().optional(),
        metadata: z.any(),
        metadataType: z.string().optional(),
        payloadType: z.string().optional(),
        tags: RunTags.optional(),
        test: z.boolean().optional(),
        ttl: z.string().or(z.number().nonnegative().int()).optional(),
        priority: z.number().optional(),
        bulkActionId: z.string().optional(),
        region: z.string().optional(),
    })
        .optional(),
});
export const TriggerTaskResponse = z.object({
    id: z.string(),
    isCached: z.boolean().optional(),
});
export const BatchTriggerTaskRequestBody = z.object({
    items: TriggerTaskRequestBody.array(),
    dependentAttempt: z.string().optional(),
});
export const BatchTriggerTaskItem = z.object({
    task: z.string(),
    payload: z.any(),
    context: z.any(),
    options: z
        .object({
        concurrencyKey: z.string().optional(),
        delay: z.string().or(z.coerce.date()).optional(),
        idempotencyKey: z.string().optional(),
        idempotencyKeyTTL: z.string().optional(),
        lockToVersion: z.string().optional(),
        machine: MachinePresetName.optional(),
        maxAttempts: z.number().int().optional(),
        maxDuration: z.number().optional(),
        metadata: z.any(),
        metadataType: z.string().optional(),
        parentAttempt: z.string().optional(),
        payloadType: z.string().optional(),
        queue: z
            .object({
            name: z.string(),
        })
            .optional(),
        tags: RunTags.optional(),
        test: z.boolean().optional(),
        ttl: z.string().or(z.number().nonnegative().int()).optional(),
        priority: z.number().optional(),
        region: z.string().optional(),
    })
        .optional(),
});
export const BatchTriggerTaskV2RequestBody = z.object({
    items: BatchTriggerTaskItem.array(),
    /** @deprecated engine v1 only */
    dependentAttempt: z.string().optional(),
    /**
     * RunEngine v2
     * If triggered inside another run, the parentRunId is the friendly ID of the parent run.
     */
    parentRunId: z.string().optional(),
    /**
     * RunEngine v2
     * Should be `true` if `triggerAndWait` or `batchTriggerAndWait`
     */
    resumeParentOnCompletion: z.boolean().optional(),
});
export const BatchTriggerTaskV2Response = z.object({
    id: z.string(),
    isCached: z.boolean(),
    idempotencyKey: z.string().optional(),
    runs: z.array(z.object({
        id: z.string(),
        taskIdentifier: z.string(),
        isCached: z.boolean(),
        idempotencyKey: z.string().optional(),
    })),
});
export const BatchTriggerTaskV3RequestBody = z.object({
    items: BatchTriggerTaskItem.array(),
    /**
     * RunEngine v2
     * If triggered inside another run, the parentRunId is the friendly ID of the parent run.
     */
    parentRunId: z.string().optional(),
    /**
     * RunEngine v2
     * Should be `true` if `triggerAndWait` or `batchTriggerAndWait`
     */
    resumeParentOnCompletion: z.boolean().optional(),
});
export const BatchTriggerTaskV3Response = z.object({
    id: z.string(),
    runCount: z.number(),
});
export const BatchTriggerTaskResponse = z.object({
    batchId: z.string(),
    runs: z.string().array(),
});
export const GetBatchResponseBody = z.object({
    id: z.string(),
    items: z.array(z.object({
        id: z.string(),
        taskRunId: z.string(),
        status: z.enum(["PENDING", "CANCELED", "COMPLETED", "FAILED"]),
    })),
});
export const AddTagsRequestBody = z.object({
    tags: RunTags,
});
export const RescheduleRunRequestBody = z.object({
    delay: z.string().or(z.coerce.date()),
});
export const GetEnvironmentVariablesResponseBody = z.object({
    variables: z.record(z.string()),
});
export const StartDeploymentIndexingRequestBody = z.object({
    imageReference: z.string(),
    selfHosted: z.boolean().optional(),
});
export const StartDeploymentIndexingResponseBody = z.object({
    id: z.string(),
    contentHash: z.string(),
});
export const FinalizeDeploymentRequestBody = z.object({
    skipPromotion: z.boolean().optional(),
    imageDigest: z.string().optional(),
});
export const ExternalBuildData = z.object({
    buildId: z.string(),
    buildToken: z.string(),
    projectId: z.string(),
});
export const UpsertBranchRequestBody = z.object({
    git: GitMeta.optional(),
    env: z.enum(["preview"]),
    branch: z.string(),
});
export const UpsertBranchResponseBody = z.object({
    id: z.string(),
});
export const InitializeDeploymentResponseBody = z.object({
    id: z.string(),
    contentHash: z.string(),
    shortCode: z.string(),
    version: z.string(),
    imageTag: z.string(),
    imagePlatform: z.string(),
    externalBuildData: ExternalBuildData.optional().nullable(),
});
export const InitializeDeploymentRequestBody = z.object({
    contentHash: z.string(),
    userId: z.string().optional(),
    /** @deprecated This is now determined by the webapp. This is only used to warn users with old CLI versions. */
    selfHosted: z.boolean().optional(),
    gitMeta: GitMeta.optional(),
    type: z.enum(["MANAGED", "UNMANAGED", "V1"]).optional(),
    runtime: z.string().optional(),
});
export const DeploymentErrorData = z.object({
    name: z.string(),
    message: z.string(),
    stack: z.string().optional(),
    stderr: z.string().optional(),
});
export const FailDeploymentRequestBody = z.object({
    error: DeploymentErrorData,
});
export const FailDeploymentResponseBody = z.object({
    id: z.string(),
});
export const PromoteDeploymentResponseBody = z.object({
    id: z.string(),
    version: z.string(),
    shortCode: z.string(),
});
export const GetDeploymentResponseBody = z.object({
    id: z.string(),
    status: z.enum([
        "PENDING",
        "BUILDING",
        "DEPLOYING",
        "DEPLOYED",
        "FAILED",
        "CANCELED",
        "TIMED_OUT",
    ]),
    contentHash: z.string(),
    shortCode: z.string(),
    version: z.string(),
    imageReference: z.string().nullish(),
    errorData: DeploymentErrorData.nullish(),
    worker: z
        .object({
        id: z.string(),
        version: z.string(),
        tasks: z.array(z.object({
            id: z.string(),
            slug: z.string(),
            filePath: z.string(),
            exportName: z.string().optional(),
        })),
    })
        .optional(),
});
export const GetLatestDeploymentResponseBody = GetDeploymentResponseBody.omit({
    worker: true,
});
export const CreateUploadPayloadUrlResponseBody = z.object({
    presignedUrl: z.string(),
});
export const WorkersListResponseBody = z
    .object({
    type: z.string(),
    name: z.string(),
    description: z.string().nullish(),
    latestVersion: z.string().nullish(),
    lastHeartbeatAt: z.string().nullish(),
    isDefault: z.boolean(),
    updatedAt: z.coerce.date(),
})
    .array();
export const WorkersCreateRequestBody = z.object({
    name: z.string().optional(),
    description: z.string().optional(),
});
export const WorkersCreateResponseBody = z.object({
    workerGroup: z.object({
        name: z.string(),
        description: z.string().nullish(),
    }),
    token: z.object({
        plaintext: z.string(),
    }),
});
export const DevConfigResponseBody = z.object({
    environmentId: z.string(),
    dequeueIntervalWithRun: z.number(),
    dequeueIntervalWithoutRun: z.number(),
    maxConcurrentRuns: z.number(),
    engineUrl: z.string(),
});
export const DevDequeueRequestBody = z.object({
    currentWorker: z.string(),
    oldWorkers: z.string().array(),
    maxResources: MachineResources.optional(),
});
export const DevDequeueResponseBody = z.object({
    dequeuedMessages: DequeuedMessage.array(),
});
export const ReplayRunResponse = z.object({
    id: z.string(),
});
export const CanceledRunResponse = z.object({
    id: z.string(),
});
export const ScheduleType = z.union([z.literal("DECLARATIVE"), z.literal("IMPERATIVE")]);
export const ScheduledTaskPayload = z.object({
    /** The schedule id associated with this run (you can have many schedules for the same task).
      You can use this to remove the schedule, update it, etc */
    scheduleId: z.string(),
    /** The type of schedule – `"DECLARATIVE"` or `"IMPERATIVE"`.
     *
     * **DECLARATIVE** – defined inline on your `schedules.task` using the `cron` property. They can only be created, updated or deleted by modifying the `cron` property on your task.
     *
     * **IMPERATIVE** – created using the `schedules.create` functions or in the dashboard.
     */
    type: ScheduleType,
    /** When the task was scheduled to run.
     * Note this will be slightly different from `new Date()` because it takes a few ms to run the task.
     *
     * This date is UTC. To output it as a string with a timezone you would do this:
     * ```ts
     * const formatted = payload.timestamp.toLocaleString("en-US", {
          timeZone: payload.timezone,
      });
      ```  */
    timestamp: z.date(),
    /** When the task was last run (it has been).
      This can be undefined if it's never been run. This date is UTC. */
    lastTimestamp: z.date().optional(),
    /** You can optionally provide an external id when creating the schedule.
      Usually you would use a userId or some other unique identifier.
      This defaults to undefined if you didn't provide one. */
    externalId: z.string().optional(),
    /** The IANA timezone the schedule is set to. The default is UTC.
     * You can see the full list of supported timezones here: https://cloud.trigger.dev/timezones
     */
    timezone: z.string(),
    /** The next 5 dates this task is scheduled to run */
    upcoming: z.array(z.date()),
});
export const CreateScheduleOptions = z.object({
    /** The id of the task you want to attach to. */
    task: z.string(),
    /**  The schedule in CRON format.
     *
     * ```txt
  *    *    *    *    *    *
  ┬    ┬    ┬    ┬    ┬
  │    │    │    │    |
  │    │    │    │    └ day of week (0 - 7, 1L - 7L) (0 or 7 is Sun)
  │    │    │    └───── month (1 - 12)
  │    │    └────────── day of month (1 - 31, L)
  │    └─────────────── hour (0 - 23)
  └──────────────────── minute (0 - 59)
     * ```
  
  "L" means the last. In the "day of week" field, 1L means the last Monday of the month. In the day of month field, L means the last day of the month.
  
     */
    cron: z.string(),
    /** You can only create one schedule with this key. If you use it twice, the second call will update the schedule.
     *
     * This is required to prevent you from creating duplicate schedules. */
    deduplicationKey: z.string(),
    /** Optionally, you can specify your own IDs (like a user ID) and then use it inside the run function of your task.
     *
     * This allows you to have per-user CRON tasks.
     */
    externalId: z.string().optional(),
    /** Optionally, you can specify a timezone in the IANA format. If unset it will use UTC.
     * If specified then the CRON will be evaluated in that timezone and will respect daylight savings.
     *
     * If you set the CRON to `0 0 * * *` and the timezone to `America/New_York` then the task will run at midnight in New York time, no matter whether it's daylight savings or not.
     *
     * You can see the full list of supported timezones here: https://cloud.trigger.dev/timezones
     *
     * @example "America/New_York", "Europe/London", "Asia/Tokyo", "Africa/Cairo"
     *
     */
    timezone: z.string().optional(),
});
export const UpdateScheduleOptions = CreateScheduleOptions.omit({ deduplicationKey: true });
export const ScheduleGenerator = z.object({
    type: z.literal("CRON"),
    expression: z.string(),
    description: z.string(),
});
export const ScheduleObject = z.object({
    id: z.string(),
    type: ScheduleType,
    task: z.string(),
    active: z.boolean(),
    deduplicationKey: z.string().nullish(),
    externalId: z.string().nullish(),
    generator: ScheduleGenerator,
    timezone: z.string(),
    nextRun: z.coerce.date().nullish(),
    environments: z.array(z.object({
        id: z.string(),
        type: z.string(),
        userName: z.string().nullish(),
    })),
});
export const DeletedScheduleObject = z.object({
    id: z.string(),
});
export const ListSchedulesResult = z.object({
    data: z.array(ScheduleObject),
    pagination: z.object({
        currentPage: z.number(),
        totalPages: z.number(),
        count: z.number(),
    }),
});
export const ListScheduleOptions = z.object({
    page: z.number().optional(),
    perPage: z.number().optional(),
});
export const TimezonesResult = z.object({
    timezones: z.array(z.string()),
});
export const RunStatus = z.enum([
    /// Task is waiting for a version update because it cannot execute without additional information (task, queue, etc.)
    "PENDING_VERSION",
    /// Task is waiting to be executed by a worker
    "QUEUED",
    /// Task is waiting to be executed by a worker
    "DEQUEUED",
    /// Task is currently being executed by a worker
    "EXECUTING",
    /// Task has been paused by the system, and will be resumed by the system
    "WAITING",
    /// Task has been completed successfully
    "COMPLETED",
    /// Task has been canceled by the user
    "CANCELED",
    /// Task has been completed with errors
    "FAILED",
    /// Task has crashed and won't be retried, most likely the worker ran out of resources, e.g. memory or storage
    "CRASHED",
    /// Task has failed to complete, due to an error in the system
    "SYSTEM_FAILURE",
    /// Task has been scheduled to run at a specific time
    "DELAYED",
    /// Task has expired and won't be executed
    "EXPIRED",
    /// Task has reached it's maxDuration and has been stopped
    "TIMED_OUT",
]);
export const AttemptStatus = z.enum([
    "PENDING",
    "EXECUTING",
    "PAUSED",
    "COMPLETED",
    "FAILED",
    "CANCELED",
]);
export const RunEnvironmentDetails = z.object({
    id: z.string(),
    name: z.string(),
    user: z.string().optional(),
});
export const RunScheduleDetails = z.object({
    id: z.string(),
    externalId: z.string().optional(),
    deduplicationKey: z.string().optional(),
    generator: ScheduleGenerator,
});
export const TriggerFunction = z.enum([
    "triggerAndWait",
    "trigger",
    "batchTriggerAndWait",
    "batchTrigger",
]);
const CommonRunFields = {
    id: z.string(),
    status: RunStatus,
    taskIdentifier: z.string(),
    idempotencyKey: z.string().optional(),
    version: z.string().optional(),
    isQueued: z.boolean(),
    isExecuting: z.boolean(),
    isWaiting: z.boolean(),
    isCompleted: z.boolean(),
    isSuccess: z.boolean(),
    isFailed: z.boolean(),
    isCancelled: z.boolean(),
    isTest: z.boolean(),
    createdAt: z.coerce.date(),
    updatedAt: z.coerce.date(),
    startedAt: z.coerce.date().optional(),
    finishedAt: z.coerce.date().optional(),
    delayedUntil: z.coerce.date().optional(),
    ttl: z.string().optional(),
    expiredAt: z.coerce.date().optional(),
    tags: z.string().array(),
    costInCents: z.number(),
    baseCostInCents: z.number(),
    durationMs: z.number(),
    metadata: z.record(z.any()).optional(),
};
const RetrieveRunCommandFields = {
    ...CommonRunFields,
    depth: z.number(),
    triggerFunction: z.enum(["triggerAndWait", "trigger", "batchTriggerAndWait", "batchTrigger"]),
    batchId: z.string().optional(),
};
export const RelatedRunDetails = z.object(RetrieveRunCommandFields);
export const RetrieveRunResponse = z.object({
    ...RetrieveRunCommandFields,
    payload: z.any().optional(),
    payloadPresignedUrl: z.string().optional(),
    output: z.any().optional(),
    outputPresignedUrl: z.string().optional(),
    error: SerializedError.optional(),
    schedule: RunScheduleDetails.optional(),
    relatedRuns: z.object({
        root: RelatedRunDetails.optional(),
        parent: RelatedRunDetails.optional(),
        children: z.array(RelatedRunDetails).optional(),
    }),
    attemptCount: z.number().default(0),
});
export const ListRunResponseItem = z.object({
    ...CommonRunFields,
    env: RunEnvironmentDetails,
});
export const ListRunResponse = z.object({
    data: z.array(ListRunResponseItem),
    pagination: z.object({
        next: z.string().optional(),
        previous: z.string().optional(),
    }),
});
export const CreateEnvironmentVariableRequestBody = z.object({
    name: z.string(),
    value: z.string(),
});
export const UpdateEnvironmentVariableRequestBody = z.object({
    value: z.string(),
});
export const ImportEnvironmentVariablesRequestBody = z.object({
    variables: z.record(z.string()),
    parentVariables: z.record(z.string()).optional(),
    override: z.boolean().optional(),
});
export const EnvironmentVariableResponseBody = z.object({
    success: z.boolean(),
});
export const EnvironmentVariableValue = z.object({
    value: z.string(),
});
export const EnvironmentVariable = z.object({
    name: z.string(),
    value: z.string(),
});
export const EnvironmentVariables = z.array(EnvironmentVariable);
export const EnvironmentVariableWithSecret = z.object({
    /** The name of the env var, e.g. `DATABASE_URL` */
    name: z.string(),
    /** The value of the env var. If it's a secret, this will be a redacted value, not the real value.  */
    value: z.string(),
    /**
     * Whether the env var is a secret or not.
     * When you create env vars you can mark them as secrets.
     *
     * You can't view the value of a secret env var after setting it initially.
     * For a secret env var, the value will be redacted.
     */
    isSecret: z.boolean(),
});
export const UpdateMetadataRequestBody = FlushedRunMetadata;
export const UpdateMetadataResponseBody = z.object({
    metadata: z.record(DeserializedJsonSchema),
});
const RawShapeDate = z
    .string()
    .transform((val) => `${val}Z`)
    .pipe(z.coerce.date());
const RawOptionalShapeDate = z
    .string()
    .nullish()
    .transform((val) => (val ? new Date(`${val}Z`) : val));
export const SubscribeRunRawShape = z.object({
    id: z.string(),
    taskIdentifier: z.string(),
    friendlyId: z.string(),
    status: z.string(),
    createdAt: RawShapeDate,
    updatedAt: RawShapeDate,
    startedAt: RawOptionalShapeDate,
    delayUntil: RawOptionalShapeDate,
    queuedAt: RawOptionalShapeDate,
    expiredAt: RawOptionalShapeDate,
    completedAt: RawOptionalShapeDate,
    idempotencyKey: z.string().nullish(),
    number: z.number().default(0),
    isTest: z.boolean().default(false),
    usageDurationMs: z.number().default(0),
    costInCents: z.number().default(0),
    baseCostInCents: z.number().default(0),
    ttl: z.string().nullish(),
    payload: z.string().nullish(),
    payloadType: z.string().nullish(),
    metadata: z.string().nullish(),
    metadataType: z.string().nullish(),
    output: z.string().nullish(),
    outputType: z.string().nullish(),
    runTags: z.array(z.string()).nullish().default([]),
    error: TaskRunError.nullish(),
});
export const BatchStatus = z.enum(["PENDING", "COMPLETED"]);
export const RetrieveBatchResponse = z.object({
    id: z.string(),
    status: BatchStatus,
    idempotencyKey: z.string().optional(),
    createdAt: z.coerce.date(),
    updatedAt: z.coerce.date(),
    runCount: z.number(),
    runs: z.array(z.string()),
});
export const RetrieveBatchV2Response = z.object({
    id: z.string(),
    status: BatchStatus,
    idempotencyKey: z.string().optional(),
    createdAt: z.coerce.date(),
    updatedAt: z.coerce.date(),
    runCount: z.number(),
    runs: z.array(z.string()),
});
export const SubscribeRealtimeStreamChunkRawShape = z.object({
    id: z.string(),
    runId: z.string(),
    sequence: z.number(),
    key: z.string(),
    value: z.string(),
    createdAt: z.coerce.date(),
});
export const TimePeriod = z.string().or(z.coerce.date());
export const CreateWaitpointTokenRequestBody = z.object({
    /**
     * An optional idempotency key for the waitpoint.
     * If you use the same key twice (and the key hasn't expired), you will get the original waitpoint back.
     *
     * Note: This waitpoint may already be complete, in which case when you wait for it, it will immediately continue.
     */
    idempotencyKey: z.string().optional(),
    /**
     * When set, this means the passed in idempotency key will expire after this time.
     * This means after that time if you pass the same idempotency key again, you will get a new waitpoint.
     */
    idempotencyKeyTTL: z.string().optional(),
    /** The resume token will timeout after this time.
     * If you are waiting for the token in a run, the token will return a result where `ok` is false.
     *
     * You can pass a `Date` object, or a string in this format: "30s", "1m", "2h", "3d", "4w".
     */
    timeout: TimePeriod.optional(),
    /**
     * Tags to attach to the waitpoint. Tags can be used to filter waitpoints in the dashboard.
     *
     * You can set up to 10 tags per waitpoint, they must be less than 128 characters each.
     *
     * We recommend prefixing tags with a namespace using an underscore or colon, like `user_1234567` or `org:9876543`.
     *
     * @example
     *
     * ```ts
     * await wait.createToken({ tags: ["user:1234567", "org:9876543"] });
     * ```
     */
    tags: RunTags.optional(),
});
export const CreateWaitpointTokenResponseBody = z.object({
    id: z.string(),
    isCached: z.boolean(),
    url: z.string(),
});
export const waitpointTokenStatuses = ["WAITING", "COMPLETED", "TIMED_OUT"];
export const WaitpointTokenStatus = z.enum(waitpointTokenStatuses);
export const WaitpointTokenItem = z.object({
    id: z.string(),
    /** If you make a POST request to this URL, it will complete the waitpoint. */
    url: z.string(),
    status: WaitpointTokenStatus,
    completedAt: z.coerce.date().optional(),
    completedAfter: z.coerce.date().optional(),
    timeoutAt: z.coerce.date().optional(),
    idempotencyKey: z.string().optional(),
    idempotencyKeyExpiresAt: z.coerce.date().optional(),
    tags: z.array(z.string()),
    createdAt: z.coerce.date(),
});
export const WaitpointListTokenItem = WaitpointTokenItem.omit({
    completedAfter: true,
});
export const WaitpointRetrieveTokenResponse = WaitpointListTokenItem.and(z.object({
    output: z.string().optional(),
    outputType: z.string().optional(),
    outputIsError: z.boolean().optional(),
}));
export const CompleteWaitpointTokenRequestBody = z.object({
    data: z.any().nullish(),
});
export const CompleteWaitpointTokenResponseBody = z.object({
    success: z.literal(true),
});
export const WaitForWaitpointTokenResponseBody = z.object({
    success: z.boolean(),
});
export const WaitForDurationRequestBody = z.object({
    /**
     * An optional idempotency key for the waitpoint.
     * If you use the same key twice (and the key hasn't expired), you will get the original waitpoint back.
     *
     * Note: This waitpoint may already be complete, in which case when you wait for it, it will immediately continue.
     */
    idempotencyKey: z.string().optional(),
    /**
     * When set, this means the passed in idempotency key will expire after this time.
     * This means after that time if you pass the same idempotency key again, you will get a new waitpoint.
     */
    idempotencyKeyTTL: z.string().optional(),
    /**
     * The date that the waitpoint will complete.
     */
    date: z.coerce.date(),
});
export const WaitForDurationResponseBody = z.object({
    /**
        If you pass an idempotencyKey, you may actually not need to wait.
        Use this date to determine when to continue.
    */
    waitUntil: z.coerce.date(),
    waitpoint: z.object({
        id: z.string(),
    }),
});
const WAITPOINT_TIMEOUT_ERROR_CODE = "TRIGGER_WAITPOINT_TIMEOUT";
export function isWaitpointOutputTimeout(output) {
    try {
        const json = JSON.parse(output);
        return json.code === WAITPOINT_TIMEOUT_ERROR_CODE;
    }
    catch (e) {
        return false;
    }
}
export function timeoutError(timeout) {
    return {
        code: WAITPOINT_TIMEOUT_ERROR_CODE,
        message: `Waitpoint timed out at ${timeout.toISOString()}`,
    };
}
//# sourceMappingURL=api.js.map