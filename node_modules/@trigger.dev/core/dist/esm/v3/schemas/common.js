import { z } from "zod";
import { DeserializedJsonSchema } from "../../schemas/json.js";
export const RunMetadataUpdateOperation = z.object({
    type: z.literal("update"),
    value: z.record(z.unknown()),
});
export const RunMetadataSetKeyOperation = z.object({
    type: z.literal("set"),
    key: z.string(),
    value: DeserializedJsonSchema,
});
export const RunMetadataDeleteKeyOperation = z.object({
    type: z.literal("delete"),
    key: z.string(),
});
export const RunMetadataAppendKeyOperation = z.object({
    type: z.literal("append"),
    key: z.string(),
    value: DeserializedJsonSchema,
});
export const RunMetadataRemoveFromKeyOperation = z.object({
    type: z.literal("remove"),
    key: z.string(),
    value: DeserializedJsonSchema,
});
export const RunMetadataIncrementKeyOperation = z.object({
    type: z.literal("increment"),
    key: z.string(),
    value: z.number(),
});
export const RunMetadataChangeOperation = z.discriminatedUnion("type", [
    RunMetadataUpdateOperation,
    RunMetadataSetKeyOperation,
    RunMetadataDeleteKeyOperation,
    RunMetadataAppendKeyOperation,
    RunMetadataRemoveFromKeyOperation,
    RunMetadataIncrementKeyOperation,
]);
export const FlushedRunMetadata = z.object({
    metadata: z.record(DeserializedJsonSchema).optional(),
    operations: z.array(RunMetadataChangeOperation).optional(),
    parentOperations: z.array(RunMetadataChangeOperation).optional(),
    rootOperations: z.array(RunMetadataChangeOperation).optional(),
});
// Defaults to 0.5
export const MachineCpu = z.union([
    z.literal(0.25),
    z.literal(0.5),
    z.literal(1),
    z.literal(2),
    z.literal(4),
]);
// Defaults to 1
export const MachineMemory = z.union([
    z.literal(0.25),
    z.literal(0.5),
    z.literal(1),
    z.literal(2),
    z.literal(4),
    z.literal(8),
]);
// Default is small-1x
export const MachinePresetName = z.enum([
    "micro",
    "small-1x",
    "small-2x",
    "medium-1x",
    "medium-2x",
    "large-1x",
    "large-2x",
]);
export const MachineConfig = z.object({
    cpu: MachineCpu.optional(),
    memory: MachineMemory.optional(),
    preset: MachinePresetName.optional(),
});
export const MachinePreset = z.object({
    name: MachinePresetName,
    /** unit: vCPU */
    cpu: z.number(),
    /** unit: GB */
    memory: z.number(),
    centsPerMs: z.number(),
});
export const TaskRunBuiltInError = z.object({
    type: z.literal("BUILT_IN_ERROR"),
    name: z.string(),
    message: z.string(),
    stackTrace: z.string(),
});
export const TaskRunCustomErrorObject = z.object({
    type: z.literal("CUSTOM_ERROR"),
    raw: z.string(),
});
export const TaskRunStringError = z.object({
    type: z.literal("STRING_ERROR"),
    raw: z.string(),
});
export const TaskRunInternalError = z.object({
    type: z.literal("INTERNAL_ERROR"),
    code: z.enum([
        "COULD_NOT_FIND_EXECUTOR",
        "COULD_NOT_FIND_TASK",
        "COULD_NOT_IMPORT_TASK",
        "CONFIGURED_INCORRECTLY",
        "TASK_ALREADY_RUNNING",
        "TASK_EXECUTION_FAILED",
        "TASK_EXECUTION_ABORTED",
        "TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE",
        "TASK_PROCESS_SIGKILL_TIMEOUT",
        "TASK_PROCESS_SIGSEGV",
        "TASK_PROCESS_SIGTERM",
        "TASK_PROCESS_OOM_KILLED",
        "TASK_PROCESS_MAYBE_OOM_KILLED",
        "TASK_RUN_CANCELLED",
        "TASK_INPUT_ERROR",
        "TASK_OUTPUT_ERROR",
        "TASK_MIDDLEWARE_ERROR",
        "HANDLE_ERROR_ERROR",
        "GRACEFUL_EXIT_TIMEOUT",
        "TASK_RUN_HEARTBEAT_TIMEOUT",
        "TASK_RUN_CRASHED",
        "MAX_DURATION_EXCEEDED",
        "DISK_SPACE_EXCEEDED",
        "POD_EVICTED",
        "POD_UNKNOWN_ERROR",
        "TASK_HAS_N0_EXECUTION_SNAPSHOT",
        "TASK_DEQUEUED_INVALID_STATE",
        "TASK_DEQUEUED_QUEUE_NOT_FOUND",
        "TASK_RUN_DEQUEUED_MAX_RETRIES",
        "TASK_RUN_STALLED_EXECUTING",
        "TASK_RUN_STALLED_EXECUTING_WITH_WAITPOINTS",
        "OUTDATED_SDK_VERSION",
        "TASK_DID_CONCURRENT_WAIT",
        "RECURSIVE_WAIT_DEADLOCK",
    ]),
    message: z.string().optional(),
    stackTrace: z.string().optional(),
});
export const TaskRunErrorCodes = TaskRunInternalError.shape.code.enum;
export const TaskRunError = z.discriminatedUnion("type", [
    TaskRunBuiltInError,
    TaskRunCustomErrorObject,
    TaskRunStringError,
    TaskRunInternalError,
]);
export const TaskRun = z.object({
    id: z.string(),
    payload: z.string(),
    payloadType: z.string(),
    tags: z.array(z.string()),
    isTest: z.boolean().default(false),
    createdAt: z.coerce.date(),
    startedAt: z.coerce.date().default(() => new Date()),
    idempotencyKey: z.string().optional(),
    maxAttempts: z.number().optional(),
    version: z.string().optional(),
    metadata: z.record(DeserializedJsonSchema).optional(),
    maxDuration: z.number().optional(),
    /** The priority of the run. Wih a value of 10 it will be dequeued before runs that were triggered 9 seconds before it (assuming they had no priority set).  */
    priority: z.number().optional(),
    baseCostInCents: z.number().optional(),
    parentTaskRunId: z.string().optional(),
    rootTaskRunId: z.string().optional(),
    // These are only used during execution, not in run.ctx
    durationMs: z.number().optional(),
    costInCents: z.number().optional(),
    region: z.string().optional(),
});
// newly added fields need to be optional for backwards compatibility
export const GitMeta = z.object({
    provider: z.string().optional(),
    source: z.enum(["trigger_github_app", "github_actions", "local"]).optional(),
    ghUsername: z.string().optional(),
    ghUserAvatarUrl: z.string().optional(),
    commitAuthorName: z.string().optional(),
    commitMessage: z.string().optional(),
    commitRef: z.string().optional(),
    commitSha: z.string().optional(),
    dirty: z.boolean().optional(),
    remoteUrl: z.string().optional(),
    pullRequestNumber: z.number().optional(),
    pullRequestTitle: z.string().optional(),
    pullRequestState: z.enum(["open", "closed", "merged"]).optional(),
});
export const TaskRunExecutionTask = z.object({
    id: z.string(),
    filePath: z.string(),
});
export const TaskRunExecutionAttempt = z.object({
    number: z.number(),
    startedAt: z.coerce.date(),
});
export const TaskRunExecutionEnvironment = z.object({
    id: z.string(),
    slug: z.string(),
    type: z.enum(["PRODUCTION", "STAGING", "DEVELOPMENT", "PREVIEW"]),
    branchName: z.string().optional(),
    git: GitMeta.optional(),
});
export const TaskRunExecutionOrganization = z.object({
    id: z.string(),
    slug: z.string(),
    name: z.string(),
});
export const TaskRunExecutionProject = z.object({
    id: z.string(),
    ref: z.string(),
    slug: z.string(),
    name: z.string(),
});
export const TaskRunExecutionQueue = z.object({
    id: z.string(),
    name: z.string(),
});
export const TaskRunExecutionBatch = z.object({
    id: z.string(),
});
export const TaskRunExecutionDeployment = z.object({
    id: z.string(),
    shortCode: z.string(),
    version: z.string(),
    runtime: z.string(),
    runtimeVersion: z.string(),
    git: GitMeta.optional(),
});
const StaticTaskRunExecutionShape = {
    // Passthrough needed for backwards compatibility
    task: TaskRunExecutionTask.passthrough(),
    queue: TaskRunExecutionQueue,
    environment: TaskRunExecutionEnvironment,
    organization: TaskRunExecutionOrganization,
    project: TaskRunExecutionProject,
    machine: MachinePreset,
    batch: TaskRunExecutionBatch.optional(),
    deployment: TaskRunExecutionDeployment.optional(),
};
export const StaticTaskRunExecution = z.object(StaticTaskRunExecutionShape);
export const TaskRunExecution = z.object({
    // Passthrough needed for backwards compatibility
    attempt: TaskRunExecutionAttempt.passthrough(),
    run: TaskRun.and(z.object({
        traceContext: z.record(z.unknown()).optional(),
    })),
    ...StaticTaskRunExecutionShape,
});
export const V3TaskRunExecutionTask = z.object({
    id: z.string(),
    filePath: z.string(),
    exportName: z.string().optional(),
});
export const V3TaskRunExecutionAttempt = z.object({
    number: z.number(),
    startedAt: z.coerce.date(),
    id: z.string(),
    backgroundWorkerId: z.string(),
    backgroundWorkerTaskId: z.string(),
    status: z.string(),
});
export const V3TaskRun = z.object({
    id: z.string(),
    payload: z.string(),
    payloadType: z.string(),
    tags: z.array(z.string()),
    isTest: z.boolean().default(false),
    createdAt: z.coerce.date(),
    startedAt: z.coerce.date().default(() => new Date()),
    idempotencyKey: z.string().optional(),
    maxAttempts: z.number().optional(),
    version: z.string().optional(),
    metadata: z.record(DeserializedJsonSchema).optional(),
    maxDuration: z.number().optional(),
    context: z.unknown(),
    durationMs: z.number(),
    costInCents: z.number(),
    baseCostInCents: z.number(),
});
export const V3TaskRunExecution = z.object({
    task: V3TaskRunExecutionTask,
    attempt: V3TaskRunExecutionAttempt,
    run: V3TaskRun.and(z.object({
        traceContext: z.record(z.unknown()).optional(),
    })),
    queue: TaskRunExecutionQueue,
    environment: TaskRunExecutionEnvironment,
    organization: TaskRunExecutionOrganization,
    project: TaskRunExecutionProject,
    machine: MachinePreset,
    batch: TaskRunExecutionBatch.optional(),
});
export const TaskRunContext = z.object({
    attempt: TaskRunExecutionAttempt,
    run: TaskRun.omit({
        payload: true,
        payloadType: true,
        metadata: true,
        durationMs: true,
        costInCents: true,
    }),
    ...StaticTaskRunExecutionShape,
});
export const V3TaskRunExecutionEnvironment = z.object({
    id: z.string(),
    slug: z.string(),
    type: z.enum(["PRODUCTION", "STAGING", "DEVELOPMENT", "PREVIEW"]),
});
export const V3TaskRunContext = z.object({
    attempt: V3TaskRunExecutionAttempt.omit({
        backgroundWorkerId: true,
        backgroundWorkerTaskId: true,
    }),
    run: V3TaskRun.omit({
        payload: true,
        payloadType: true,
        metadata: true,
    }),
    task: V3TaskRunExecutionTask,
    queue: TaskRunExecutionQueue,
    environment: V3TaskRunExecutionEnvironment,
    organization: TaskRunExecutionOrganization,
    project: TaskRunExecutionProject,
    batch: TaskRunExecutionBatch.optional(),
    machine: MachinePreset.optional(),
});
export const TaskRunExecutionRetry = z.object({
    timestamp: z.number(),
    /** Retry delay in milliseconds */
    delay: z.number(),
    error: z.unknown().optional(),
});
export const TaskRunExecutionUsage = z.object({
    durationMs: z.number(),
});
export const TaskRunFailedExecutionResult = z.object({
    ok: z.literal(false),
    id: z.string(),
    error: TaskRunError,
    retry: TaskRunExecutionRetry.optional(),
    skippedRetrying: z.boolean().optional(),
    usage: TaskRunExecutionUsage.optional(),
    // Optional for now for backwards compatibility
    taskIdentifier: z.string().optional(),
    // This is deprecated, use flushedMetadata instead
    metadata: FlushedRunMetadata.optional(),
    // This is the new way to flush metadata
    flushedMetadata: z
        .object({
        data: z.string().optional(),
        dataType: z.string(),
    })
        .optional(),
});
export const TaskRunSuccessfulExecutionResult = z.object({
    ok: z.literal(true),
    id: z.string(),
    output: z.string().optional(),
    outputType: z.string(),
    usage: TaskRunExecutionUsage.optional(),
    // Optional for now for backwards compatibility
    taskIdentifier: z.string().optional(),
    // This is deprecated, use flushedMetadata instead
    metadata: FlushedRunMetadata.optional(),
    // This is the new way to flush metadata
    flushedMetadata: z
        .object({
        data: z.string().optional(),
        dataType: z.string(),
    })
        .optional(),
});
export const TaskRunExecutionResult = z.discriminatedUnion("ok", [
    TaskRunSuccessfulExecutionResult,
    TaskRunFailedExecutionResult,
]);
export const BatchTaskRunExecutionResult = z.object({
    id: z.string(),
    items: TaskRunExecutionResult.array(),
});
export const WaitpointTokenResult = z.object({
    ok: z.boolean(),
    output: z.string().optional(),
    outputType: z.string().optional(),
});
export const SerializedError = z.object({
    message: z.string(),
    name: z.string().optional(),
    stackTrace: z.string().optional(),
});
export const RuntimeEnvironmentType = {
    PRODUCTION: "PRODUCTION",
    STAGING: "STAGING",
    DEVELOPMENT: "DEVELOPMENT",
    PREVIEW: "PREVIEW",
};
export const RuntimeEnvironmentTypeSchema = z.enum(Object.values(RuntimeEnvironmentType));
//# sourceMappingURL=common.js.map