import { trace } from "@opentelemetry/api";
import { SemanticInternalAttributes } from "../semanticInternalAttributes.js";
import { taskContext } from "../task-context-api.js";
import { flattenAttributes } from "../utils/flattenAttributes.js";
export class TaskContextSpanProcessor {
    _innerProcessor;
    _tracer;
    constructor(version, innerProcessor) {
        this._tracer = trace.getTracer("trigger-dev-worker", version);
        this._innerProcessor = innerProcessor;
    }
    // Called when a span starts
    onStart(span, parentContext) {
        if (taskContext.ctx) {
            span.setAttributes(flattenAttributes(taskContext.attributes, SemanticInternalAttributes.METADATA));
        }
        if (!isPartialSpan(span) && !skipPartialSpan(span)) {
            const partialSpan = createPartialSpan(this._tracer, span, parentContext);
            partialSpan.end();
        }
        this._innerProcessor.onStart(span, parentContext);
    }
    // Delegate the rest of the methods to the wrapped processor
    onEnd(span) {
        this._innerProcessor.onEnd(span);
    }
    shutdown() {
        return this._innerProcessor.shutdown();
    }
    forceFlush() {
        return this._innerProcessor.forceFlush();
    }
}
function isPartialSpan(span) {
    return span.attributes[SemanticInternalAttributes.SPAN_PARTIAL] === true;
}
function skipPartialSpan(span) {
    return span.attributes[SemanticInternalAttributes.SKIP_SPAN_PARTIAL] === true;
}
function createPartialSpan(tracer, span, parentContext) {
    const partialSpan = tracer.startSpan(span.name, {
        attributes: {
            [SemanticInternalAttributes.SPAN_PARTIAL]: true,
            [SemanticInternalAttributes.SPAN_ID]: span.spanContext().spanId,
            ...span.attributes,
        },
    }, parentContext);
    if (taskContext.ctx) {
        partialSpan.setAttributes(flattenAttributes(taskContext.attributes, SemanticInternalAttributes.METADATA));
    }
    if (span.events) {
        for (const event of span.events) {
            partialSpan.addEvent(event.name, event.attributes, event.time);
        }
    }
    return partialSpan;
}
export class TaskContextLogProcessor {
    _innerProcessor;
    constructor(innerProcessor) {
        this._innerProcessor = innerProcessor;
    }
    forceFlush() {
        return this._innerProcessor.forceFlush();
    }
    onEmit(logRecord, context) {
        // Adds in the context attributes to the log record
        if (taskContext.ctx) {
            logRecord.setAttributes(flattenAttributes(taskContext.attributes, SemanticInternalAttributes.METADATA));
        }
        this._innerProcessor.onEmit(logRecord, context);
    }
    shutdown() {
        return this._innerProcessor.shutdown();
    }
}
//# sourceMappingURL=otelProcessors.js.map