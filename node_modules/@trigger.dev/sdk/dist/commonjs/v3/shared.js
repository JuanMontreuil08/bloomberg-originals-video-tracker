"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaskRunPromise = exports.SubtaskUnwrapError = void 0;
exports.queue = queue;
exports.createTask = createTask;
exports.createToolTask = createToolTask;
exports.createSchemaTask = createSchemaTask;
exports.trigger = trigger;
exports.triggerAndWait = triggerAndWait;
exports.batchTriggerAndWait = batchTriggerAndWait;
exports.batchTrigger = batchTrigger;
exports.batchTriggerById = batchTriggerById;
exports.batchTriggerByIdAndWait = batchTriggerByIdAndWait;
exports.batchTriggerTasks = batchTriggerTasks;
exports.batchTriggerAndWaitTasks = batchTriggerAndWaitTasks;
const api_1 = require("@opentelemetry/api");
const v3_1 = require("@trigger.dev/core/v3");
Object.defineProperty(exports, "SubtaskUnwrapError", { enumerable: true, get: function () { return v3_1.SubtaskUnwrapError; } });
Object.defineProperty(exports, "TaskRunPromise", { enumerable: true, get: function () { return v3_1.TaskRunPromise; } });
const tracer_js_1 = require("./tracer.js");
function queue(options) {
    v3_1.resourceCatalog.registerQueueMetadata(options);
    // @ts-expect-error
    options[Symbol.for("trigger.dev/queue")] = true;
    return options;
}
function createTask(params) {
    const task = {
        id: params.id,
        description: params.description,
        jsonSchema: params.jsonSchema,
        trigger: async (payload, options) => {
            return await trigger_internal("trigger()", params.id, payload, undefined, {
                queue: params.queue?.name,
                ...options,
            });
        },
        batchTrigger: async (items, options) => {
            return await batchTrigger_internal("batchTrigger()", params.id, items, options, undefined, undefined, params.queue?.name);
        },
        triggerAndWait: (payload, options) => {
            return new v3_1.TaskRunPromise((resolve, reject) => {
                triggerAndWait_internal("triggerAndWait()", params.id, payload, undefined, {
                    queue: params.queue?.name,
                    ...options,
                })
                    .then((result) => {
                    resolve(result);
                })
                    .catch((error) => {
                    reject(error);
                });
            }, params.id);
        },
        batchTriggerAndWait: async (items, options) => {
            return await batchTriggerAndWait_internal("batchTriggerAndWait()", params.id, items, undefined, options, undefined, params.queue?.name);
        },
    };
    registerTaskLifecycleHooks(params.id, params);
    v3_1.resourceCatalog.registerTaskMetadata({
        id: params.id,
        description: params.description,
        queue: params.queue,
        retry: params.retry ? { ...v3_1.defaultRetryOptions, ...params.retry } : undefined,
        machine: typeof params.machine === "string" ? { preset: params.machine } : params.machine,
        maxDuration: params.maxDuration,
        payloadSchema: params.jsonSchema,
        fns: {
            run: params.run,
        },
    });
    const queue = params.queue;
    if (queue && typeof queue.name === "string") {
        v3_1.resourceCatalog.registerQueueMetadata({
            name: queue.name,
            concurrencyLimit: queue.concurrencyLimit,
        });
    }
    // @ts-expect-error
    task[Symbol.for("trigger.dev/task")] = true;
    return task;
}
/**
 * @deprecated use ai.tool() instead
 */
function createToolTask(params) {
    const task = createSchemaTask({
        ...params,
        schema: (0, v3_1.convertToolParametersToSchema)(params.parameters),
    });
    return {
        ...task,
        tool: {
            parameters: params.parameters,
            description: params.description,
            execute: async (args) => {
                return task.triggerAndWait(args).unwrap();
            },
        },
    };
}
function createSchemaTask(params) {
    const parsePayload = params.schema
        ? (0, v3_1.getSchemaParseFn)(params.schema)
        : undefined;
    const task = {
        id: params.id,
        description: params.description,
        schema: params.schema,
        trigger: async (payload, options, requestOptions) => {
            return await trigger_internal("trigger()", params.id, payload, parsePayload, {
                queue: params.queue?.name,
                ...options,
            }, requestOptions);
        },
        batchTrigger: async (items, options, requestOptions) => {
            return await batchTrigger_internal("batchTrigger()", params.id, items, options, parsePayload, requestOptions, params.queue?.name);
        },
        triggerAndWait: (payload, options) => {
            return new v3_1.TaskRunPromise((resolve, reject) => {
                triggerAndWait_internal("triggerAndWait()", params.id, payload, parsePayload, {
                    queue: params.queue?.name,
                    ...options,
                })
                    .then((result) => {
                    resolve(result);
                })
                    .catch((error) => {
                    reject(error);
                });
            }, params.id);
        },
        batchTriggerAndWait: async (items, options) => {
            return await batchTriggerAndWait_internal("batchTriggerAndWait()", params.id, items, parsePayload, options, undefined, params.queue?.name);
        },
    };
    registerTaskLifecycleHooks(params.id, params);
    v3_1.resourceCatalog.registerTaskMetadata({
        id: params.id,
        description: params.description,
        queue: params.queue,
        retry: params.retry ? { ...v3_1.defaultRetryOptions, ...params.retry } : undefined,
        machine: typeof params.machine === "string" ? { preset: params.machine } : params.machine,
        maxDuration: params.maxDuration,
        fns: {
            run: params.run,
            parsePayload,
        },
        schema: params.schema,
    });
    const queue = params.queue;
    if (queue && typeof queue.name === "string") {
        v3_1.resourceCatalog.registerQueueMetadata({
            name: queue.name,
            concurrencyLimit: queue.concurrencyLimit,
        });
    }
    // @ts-expect-error
    task[Symbol.for("trigger.dev/task")] = true;
    return task;
}
/**
 * Trigger a task by its identifier with the given payload. Returns a typesafe `RunHandle`.
 *
 * @example
 *
 * ```ts
 * import { tasks, runs } from "@trigger.dev/sdk/v3";
 * import type { myTask } from "./myTasks"; // Import just the type of the task
 *
 * const handle = await tasks.trigger<typeof myTask>("my-task", { foo: "bar" }); // The id and payload are fully typesafe
 * const run = await runs.retrieve(handle);
 * console.log(run.output) // The output is also fully typed
 * ```
 *
 * @returns {RunHandle} An object with the `id` of the run. Can be used to retrieve the completed run output in a typesafe manner.
 */
async function trigger(id, payload, options, requestOptions) {
    return await trigger_internal("tasks.trigger()", id, payload, undefined, options, requestOptions);
}
/**
 * Trigger a task with the given payload, and wait for the result. Returns the result of the task run
 * @param id - The id of the task to trigger
 * @param payload
 * @param options - Options for the task run
 * @returns TaskRunResult
 * @example
 * ```ts
 * import { tasks } from "@trigger.dev/sdk/v3";
 * const result = await tasks.triggerAndWait("my-task", { foo: "bar" });
 *
 * if (result.ok) {
 *  console.log(result.output);
 * } else {
 *  console.error(result.error);
 * }
 * ```
 */
function triggerAndWait(id, payload, options, requestOptions) {
    return new v3_1.TaskRunPromise((resolve, reject) => {
        triggerAndWait_internal("tasks.triggerAndWait()", id, payload, undefined, options, requestOptions)
            .then((result) => {
            resolve(result);
        })
            .catch((error) => {
            reject(error);
        });
    }, id);
}
/**
 * Batch trigger multiple task runs with the given payloads, and wait for the results. Returns the results of the task runs.
 * @param id - The id of the task to trigger
 * @param items
 * @returns BatchResult
 * @example
 *
 * ```ts
 * import { tasks } from "@trigger.dev/sdk/v3";
 *
 * const result = await tasks.batchTriggerAndWait("my-task", [
 *  { payload: { foo: "bar" } },
 *  { payload: { foo: "baz" } },
 * ]);
 *
 * for (const run of result.runs) {
 *  if (run.ok) {
 *    console.log(run.output);
 *  } else {
 *    console.error(run.error);
 *  }
 * }
 * ```
 */
async function batchTriggerAndWait(id, items, options, requestOptions) {
    return await batchTriggerAndWait_internal("tasks.batchTriggerAndWait()", id, items, undefined, options, requestOptions);
}
async function batchTrigger(id, items, options, requestOptions) {
    return await batchTrigger_internal("tasks.batchTrigger()", id, items, options, undefined, requestOptions);
}
/**
 * Triggers multiple runs of different tasks with specified payloads and options.
 *
 * @template TTask - The type of task(s) to be triggered, extends AnyTask
 *
 * @param {Array<BatchByIdItem<InferRunTypes<TTask>>>} items - Array of task items to trigger
 * @param {BatchTriggerOptions} [options] - Optional batch-level trigger options
 * @param {TriggerApiRequestOptions} [requestOptions] - Optional API request configuration
 *
 * @returns {Promise<BatchRunHandleFromTypes<InferRunTypes<TTask>>>} A promise that resolves with the batch run handle
 * containing batch ID, cached status, idempotency info, runs, and public access token
 *
 * @example
 * ```ts
 * import { batch } from "@trigger.dev/sdk/v3";
 * import type { myTask1, myTask2 } from "~/trigger/myTasks";
 *
 * // Trigger multiple tasks with different payloads
 * const result = await batch.trigger<typeof myTask1 | typeof myTask2>([
 *   {
 *     id: "my-task-1",
 *     payload: { some: "data" },
 *     options: {
 *       queue: "default",
 *       concurrencyKey: "key",
 *       idempotencyKey: "unique-key",
 *       delay: "5m",
 *       tags: ["tag1", "tag2"]
 *     }
 *   },
 *   {
 *     id: "my-task-2",
 *     payload: { other: "data" }
 *   }
 * ]);
 * ```
 *
 * @description
 * Each task item in the array can include:
 * - `id`: The unique identifier of the task
 * - `payload`: The data to pass to the task
 * - `options`: Optional task-specific settings including:
 *   - `queue`: Specify a queue for the task
 *   - `concurrencyKey`: Control concurrent execution
 *   - `idempotencyKey`: Prevent duplicate runs
 *   - `idempotencyKeyTTL`: Time-to-live for idempotency key
 *   - `delay`: Delay before task execution
 *   - `ttl`: Time-to-live for the task
 *   - `tags`: Array of tags for the task
 *   - `maxAttempts`: Maximum retry attempts
 *   - `metadata`: Additional metadata
 *   - `maxDuration`: Maximum execution duration
 */
async function batchTriggerById(items, options, requestOptions) {
    const apiClient = v3_1.apiClientManager.clientOrThrow();
    const response = await apiClient.batchTriggerV3({
        items: await Promise.all(items.map(async (item, index) => {
            const taskMetadata = v3_1.resourceCatalog.getTask(item.id);
            const parsedPayload = taskMetadata?.fns.parsePayload
                ? await taskMetadata?.fns.parsePayload(item.payload)
                : item.payload;
            const payloadPacket = await (0, v3_1.stringifyIO)(parsedPayload);
            const batchItemIdempotencyKey = await (0, v3_1.makeIdempotencyKey)((0, v3_1.flattenIdempotencyKey)([options?.idempotencyKey, `${index}`]));
            return {
                task: item.id,
                payload: payloadPacket.data,
                options: {
                    queue: item.options?.queue ? { name: item.options.queue } : undefined,
                    concurrencyKey: item.options?.concurrencyKey,
                    test: v3_1.taskContext.ctx?.run.isTest,
                    payloadType: payloadPacket.dataType,
                    delay: item.options?.delay,
                    ttl: item.options?.ttl,
                    tags: item.options?.tags,
                    maxAttempts: item.options?.maxAttempts,
                    metadata: item.options?.metadata,
                    maxDuration: item.options?.maxDuration,
                    idempotencyKey: (await (0, v3_1.makeIdempotencyKey)(item.options?.idempotencyKey)) ?? batchItemIdempotencyKey,
                    idempotencyKeyTTL: item.options?.idempotencyKeyTTL ?? options?.idempotencyKeyTTL,
                    machine: item.options?.machine,
                    priority: item.options?.priority,
                    region: item.options?.region,
                    lockToVersion: item.options?.version ?? (0, v3_1.getEnvVar)("TRIGGER_VERSION"),
                },
            };
        })),
        parentRunId: v3_1.taskContext.ctx?.run.id,
    }, {
        spanParentAsLink: true,
        processingStrategy: options?.triggerSequentially ? "sequential" : undefined,
    }, {
        name: "batch.trigger()",
        tracer: tracer_js_1.tracer,
        icon: "trigger",
        onResponseBody(body, span) {
            if (body && typeof body === "object" && !Array.isArray(body)) {
                if ("id" in body && typeof body.id === "string") {
                    span.setAttribute("batchId", body.id);
                }
                if ("runCount" in body && typeof body.runCount === "number") {
                    span.setAttribute("runCount", body.runCount);
                }
            }
        },
        ...requestOptions,
    });
    const handle = {
        batchId: response.id,
        runCount: response.runCount,
        publicAccessToken: response.publicAccessToken,
    };
    return handle;
}
/**
 * Triggers multiple tasks and waits for all of them to complete before returning their results.
 * This function must be called from within a task.run() context.
 *
 * @template TTask - Union type of tasks to be triggered, extends AnyTask
 *
 * @param {Array<BatchByIdAndWaitItem<InferRunTypes<TTask>>>} items - Array of task items to trigger
 * @param {TriggerApiRequestOptions} [requestOptions] - Optional API request configuration
 *
 * @returns {Promise<BatchByIdResult<TTask>>} A promise that resolves with the batch results, including
 * success/failure status and strongly-typed outputs for each task
 *
 * @throws {Error} If called outside of a task.run() context
 * @throws {Error} If no API client is configured
 *
 * @example
 * ```ts
 * import { batch, task } from "@trigger.dev/sdk/v3";
 *
 * export const parentTask = task({
 *   id: "parent-task",
 *   run: async (payload: string) => {
 *     const results = await batch.triggerAndWait<typeof childTask1 | typeof childTask2>([
 *       {
 *         id: "child-task-1",
 *         payload: { foo: "World" },
 *         options: {
 *           queue: "default",
 *           delay: "5m",
 *           tags: ["batch", "child1"]
 *         }
 *       },
 *       {
 *         id: "child-task-2",
 *         payload: { bar: 42 }
 *       }
 *     ]);
 *
 *     // Type-safe result handling
 *     for (const result of results) {
 *       if (result.ok) {
 *         switch (result.taskIdentifier) {
 *           case "child-task-1":
 *             console.log("Child task 1 output:", result.output); // string type
 *             break;
 *           case "child-task-2":
 *             console.log("Child task 2 output:", result.output); // number type
 *             break;
 *         }
 *       } else {
 *         console.error("Task failed:", result.error);
 *       }
 *     }
 *   }
 * });
 * ```
 *
 * @description
 * Each task item in the array can include:
 * - `id`: The task identifier (must match one of the tasks in the union type)
 * - `payload`: Strongly-typed payload matching the task's input type
 * - `options`: Optional task-specific settings including:
 *   - `queue`: Specify a queue for the task
 *   - `concurrencyKey`: Control concurrent execution
 *   - `delay`: Delay before task execution
 *   - `ttl`: Time-to-live for the task
 *   - `tags`: Array of tags for the task
 *   - `maxAttempts`: Maximum retry attempts
 *   - `metadata`: Additional metadata
 *   - `maxDuration`: Maximum execution duration
 *
 * The function provides full type safety for:
 * - Task IDs
 * - Payload types
 * - Return value types
 * - Error handling
 */
async function batchTriggerByIdAndWait(items, options, requestOptions) {
    const ctx = v3_1.taskContext.ctx;
    if (!ctx) {
        throw new Error("batchTriggerAndWait can only be used from inside a task.run()");
    }
    const apiClient = v3_1.apiClientManager.clientOrThrow();
    return await tracer_js_1.tracer.startActiveSpan("batch.triggerAndWait()", async (span) => {
        const response = await apiClient.batchTriggerV3({
            items: await Promise.all(items.map(async (item, index) => {
                const taskMetadata = v3_1.resourceCatalog.getTask(item.id);
                const parsedPayload = taskMetadata?.fns.parsePayload
                    ? await taskMetadata?.fns.parsePayload(item.payload)
                    : item.payload;
                const payloadPacket = await (0, v3_1.stringifyIO)(parsedPayload);
                const batchItemIdempotencyKey = await (0, v3_1.makeIdempotencyKey)((0, v3_1.flattenIdempotencyKey)([options?.idempotencyKey, `${index}`]));
                return {
                    task: item.id,
                    payload: payloadPacket.data,
                    options: {
                        lockToVersion: v3_1.taskContext.worker?.version,
                        queue: item.options?.queue ? { name: item.options.queue } : undefined,
                        concurrencyKey: item.options?.concurrencyKey,
                        test: v3_1.taskContext.ctx?.run.isTest,
                        payloadType: payloadPacket.dataType,
                        delay: item.options?.delay,
                        ttl: item.options?.ttl,
                        tags: item.options?.tags,
                        maxAttempts: item.options?.maxAttempts,
                        metadata: item.options?.metadata,
                        maxDuration: item.options?.maxDuration,
                        idempotencyKey: (await (0, v3_1.makeIdempotencyKey)(item.options?.idempotencyKey)) ??
                            batchItemIdempotencyKey,
                        idempotencyKeyTTL: item.options?.idempotencyKeyTTL ?? options?.idempotencyKeyTTL,
                        machine: item.options?.machine,
                        priority: item.options?.priority,
                        region: item.options?.region,
                    },
                };
            })),
            parentRunId: ctx.run.id,
            resumeParentOnCompletion: true,
        }, {
            processingStrategy: options?.triggerSequentially ? "sequential" : undefined,
        }, requestOptions);
        span.setAttribute("batchId", response.id);
        span.setAttribute("runCount", response.runCount);
        const result = await v3_1.runtime.waitForBatch({
            id: response.id,
            runCount: response.runCount,
            ctx,
        });
        const runs = await handleBatchTaskRunExecutionResultV2(result.items);
        return {
            id: result.id,
            runs,
        };
    }, {
        kind: api_1.SpanKind.PRODUCER,
        attributes: {
            [v3_1.SemanticInternalAttributes.STYLE_ICON]: "trigger",
        },
    });
}
/**
 * Triggers multiple tasks and waits for all of them to complete before returning their results.
 * This function must be called from within a task.run() context.
 *
 * @template TTask - Union type of tasks to be triggered, extends AnyTask
 *
 * @param {Array<BatchByIdAndWaitItem<InferRunTypes<TTask>>>} items - Array of task items to trigger
 * @param {TriggerApiRequestOptions} [requestOptions] - Optional API request configuration
 *
 * @returns {Promise<BatchByIdResult<TTask>>} A promise that resolves with the batch results, including
 * success/failure status and strongly-typed outputs for each task
 *
 * @throws {Error} If called outside of a task.run() context
 * @throws {Error} If no API client is configured
 *
 * @example
 * ```ts
 * import { batch, task } from "@trigger.dev/sdk/v3";
 *
 * export const parentTask = task({
 *   id: "parent-task",
 *   run: async (payload: string) => {
 *     const results = await batch.triggerAndWait<typeof childTask1 | typeof childTask2>([
 *       {
 *         id: "child-task-1",
 *         payload: { foo: "World" },
 *         options: {
 *           queue: "default",
 *           delay: "5m",
 *           tags: ["batch", "child1"]
 *         }
 *       },
 *       {
 *         id: "child-task-2",
 *         payload: { bar: 42 }
 *       }
 *     ]);
 *
 *     // Type-safe result handling
 *     for (const result of results) {
 *       if (result.ok) {
 *         switch (result.taskIdentifier) {
 *           case "child-task-1":
 *             console.log("Child task 1 output:", result.output); // string type
 *             break;
 *           case "child-task-2":
 *             console.log("Child task 2 output:", result.output); // number type
 *             break;
 *         }
 *       } else {
 *         console.error("Task failed:", result.error);
 *       }
 *     }
 *   }
 * });
 * ```
 *
 * @description
 * Each task item in the array can include:
 * - `id`: The task identifier (must match one of the tasks in the union type)
 * - `payload`: Strongly-typed payload matching the task's input type
 * - `options`: Optional task-specific settings including:
 *   - `queue`: Specify a queue for the task
 *   - `concurrencyKey`: Control concurrent execution
 *   - `delay`: Delay before task execution
 *   - `ttl`: Time-to-live for the task
 *   - `tags`: Array of tags for the task
 *   - `maxAttempts`: Maximum retry attempts
 *   - `metadata`: Additional metadata
 *   - `maxDuration`: Maximum execution duration
 *
 * The function provides full type safety for:
 * - Task IDs
 * - Payload types
 * - Return value types
 * - Error handling
 */
async function batchTriggerTasks(items, options, requestOptions) {
    const apiClient = v3_1.apiClientManager.clientOrThrow();
    const response = await apiClient.batchTriggerV3({
        items: await Promise.all(items.map(async (item, index) => {
            const taskMetadata = v3_1.resourceCatalog.getTask(item.task.id);
            const parsedPayload = taskMetadata?.fns.parsePayload
                ? await taskMetadata?.fns.parsePayload(item.payload)
                : item.payload;
            const payloadPacket = await (0, v3_1.stringifyIO)(parsedPayload);
            const batchItemIdempotencyKey = await (0, v3_1.makeIdempotencyKey)((0, v3_1.flattenIdempotencyKey)([options?.idempotencyKey, `${index}`]));
            return {
                task: item.task.id,
                payload: payloadPacket.data,
                options: {
                    queue: item.options?.queue ? { name: item.options.queue } : undefined,
                    concurrencyKey: item.options?.concurrencyKey,
                    test: v3_1.taskContext.ctx?.run.isTest,
                    payloadType: payloadPacket.dataType,
                    delay: item.options?.delay,
                    ttl: item.options?.ttl,
                    tags: item.options?.tags,
                    maxAttempts: item.options?.maxAttempts,
                    metadata: item.options?.metadata,
                    maxDuration: item.options?.maxDuration,
                    idempotencyKey: (await (0, v3_1.makeIdempotencyKey)(item.options?.idempotencyKey)) ?? batchItemIdempotencyKey,
                    idempotencyKeyTTL: item.options?.idempotencyKeyTTL ?? options?.idempotencyKeyTTL,
                    machine: item.options?.machine,
                    priority: item.options?.priority,
                    region: item.options?.region,
                    lockToVersion: item.options?.version ?? (0, v3_1.getEnvVar)("TRIGGER_VERSION"),
                },
            };
        })),
        parentRunId: v3_1.taskContext.ctx?.run.id,
    }, {
        spanParentAsLink: true,
        processingStrategy: options?.triggerSequentially ? "sequential" : undefined,
    }, {
        name: "batch.triggerByTask()",
        tracer: tracer_js_1.tracer,
        icon: "trigger",
        onResponseBody(body, span) {
            if (body && typeof body === "object" && !Array.isArray(body)) {
                if ("id" in body && typeof body.id === "string") {
                    span.setAttribute("batchId", body.id);
                }
                if ("runCount" in body && typeof body.runCount === "number") {
                    span.setAttribute("runCount", body.runCount);
                }
            }
        },
        ...requestOptions,
    });
    const handle = {
        batchId: response.id,
        runCount: response.runCount,
        publicAccessToken: response.publicAccessToken,
    };
    return handle;
}
/**
 * Triggers multiple tasks and waits for all of them to complete before returning their results.
 * This function must be called from within a task.run() context.
 *
 * @template TTask - Union type of tasks to be triggered, extends AnyTask
 *
 * @param {Array<BatchByIdAndWaitItem<InferRunTypes<TTask>>>} items - Array of task items to trigger
 * @param {TriggerApiRequestOptions} [requestOptions] - Optional API request configuration
 *
 * @returns {Promise<BatchByIdResult<TTask>>} A promise that resolves with the batch results, including
 * success/failure status and strongly-typed outputs for each task
 *
 * @throws {Error} If called outside of a task.run() context
 * @throws {Error} If no API client is configured
 *
 * @example
 * ```ts
 * import { batch, task } from "@trigger.dev/sdk/v3";
 *
 * export const parentTask = task({
 *   id: "parent-task",
 *   run: async (payload: string) => {
 *     const results = await batch.triggerAndWait<typeof childTask1 | typeof childTask2>([
 *       {
 *         id: "child-task-1",
 *         payload: { foo: "World" },
 *         options: {
 *           queue: "default",
 *           delay: "5m",
 *           tags: ["batch", "child1"]
 *         }
 *       },
 *       {
 *         id: "child-task-2",
 *         payload: { bar: 42 }
 *       }
 *     ]);
 *
 *     // Type-safe result handling
 *     for (const result of results) {
 *       if (result.ok) {
 *         switch (result.taskIdentifier) {
 *           case "child-task-1":
 *             console.log("Child task 1 output:", result.output); // string type
 *             break;
 *           case "child-task-2":
 *             console.log("Child task 2 output:", result.output); // number type
 *             break;
 *         }
 *       } else {
 *         console.error("Task failed:", result.error);
 *       }
 *     }
 *   }
 * });
 * ```
 *
 * @description
 * Each task item in the array can include:
 * - `id`: The task identifier (must match one of the tasks in the union type)
 * - `payload`: Strongly-typed payload matching the task's input type
 * - `options`: Optional task-specific settings including:
 *   - `queue`: Specify a queue for the task
 *   - `concurrencyKey`: Control concurrent execution
 *   - `delay`: Delay before task execution
 *   - `ttl`: Time-to-live for the task
 *   - `tags`: Array of tags for the task
 *   - `maxAttempts`: Maximum retry attempts
 *   - `metadata`: Additional metadata
 *   - `maxDuration`: Maximum execution duration
 *
 * The function provides full type safety for:
 * - Task IDs
 * - Payload types
 * - Return value types
 * - Error handling
 */
async function batchTriggerAndWaitTasks(items, options, requestOptions) {
    const ctx = v3_1.taskContext.ctx;
    if (!ctx) {
        throw new Error("batchTriggerAndWait can only be used from inside a task.run()");
    }
    const apiClient = v3_1.apiClientManager.clientOrThrow();
    return await tracer_js_1.tracer.startActiveSpan("batch.triggerByTaskAndWait()", async (span) => {
        const response = await apiClient.batchTriggerV3({
            items: await Promise.all(items.map(async (item, index) => {
                const taskMetadata = v3_1.resourceCatalog.getTask(item.task.id);
                const parsedPayload = taskMetadata?.fns.parsePayload
                    ? await taskMetadata?.fns.parsePayload(item.payload)
                    : item.payload;
                const payloadPacket = await (0, v3_1.stringifyIO)(parsedPayload);
                const batchItemIdempotencyKey = await (0, v3_1.makeIdempotencyKey)((0, v3_1.flattenIdempotencyKey)([options?.idempotencyKey, `${index}`]));
                return {
                    task: item.task.id,
                    payload: payloadPacket.data,
                    options: {
                        lockToVersion: v3_1.taskContext.worker?.version,
                        queue: item.options?.queue ? { name: item.options.queue } : undefined,
                        concurrencyKey: item.options?.concurrencyKey,
                        test: v3_1.taskContext.ctx?.run.isTest,
                        payloadType: payloadPacket.dataType,
                        delay: item.options?.delay,
                        ttl: item.options?.ttl,
                        tags: item.options?.tags,
                        maxAttempts: item.options?.maxAttempts,
                        metadata: item.options?.metadata,
                        maxDuration: item.options?.maxDuration,
                        idempotencyKey: (await (0, v3_1.makeIdempotencyKey)(item.options?.idempotencyKey)) ??
                            batchItemIdempotencyKey,
                        idempotencyKeyTTL: item.options?.idempotencyKeyTTL ?? options?.idempotencyKeyTTL,
                        machine: item.options?.machine,
                        priority: item.options?.priority,
                        region: item.options?.region,
                    },
                };
            })),
            parentRunId: ctx.run.id,
            resumeParentOnCompletion: true,
        }, {
            processingStrategy: options?.triggerSequentially ? "sequential" : undefined,
        }, requestOptions);
        span.setAttribute("batchId", response.id);
        span.setAttribute("runCount", response.runCount);
        const result = await v3_1.runtime.waitForBatch({
            id: response.id,
            runCount: response.runCount,
            ctx,
        });
        const runs = await handleBatchTaskRunExecutionResultV2(result.items);
        return {
            id: result.id,
            runs,
        };
    }, {
        kind: api_1.SpanKind.PRODUCER,
        attributes: {
            [v3_1.SemanticInternalAttributes.STYLE_ICON]: "trigger",
        },
    });
}
async function trigger_internal(name, id, payload, parsePayload, options, requestOptions) {
    const apiClient = v3_1.apiClientManager.clientOrThrow();
    const parsedPayload = parsePayload ? await parsePayload(payload) : payload;
    const payloadPacket = await (0, v3_1.stringifyIO)(parsedPayload);
    const handle = await apiClient.triggerTask(id, {
        payload: payloadPacket.data,
        options: {
            queue: options?.queue ? { name: options.queue } : undefined,
            concurrencyKey: options?.concurrencyKey,
            test: v3_1.taskContext.ctx?.run.isTest,
            payloadType: payloadPacket.dataType,
            idempotencyKey: await (0, v3_1.makeIdempotencyKey)(options?.idempotencyKey),
            idempotencyKeyTTL: options?.idempotencyKeyTTL,
            delay: options?.delay,
            ttl: options?.ttl,
            tags: options?.tags,
            maxAttempts: options?.maxAttempts,
            metadata: options?.metadata,
            maxDuration: options?.maxDuration,
            parentRunId: v3_1.taskContext.ctx?.run.id,
            machine: options?.machine,
            priority: options?.priority,
            region: options?.region,
            lockToVersion: options?.version ?? (0, v3_1.getEnvVar)("TRIGGER_VERSION"),
        },
    }, {
        spanParentAsLink: true,
    }, {
        name,
        tracer: tracer_js_1.tracer,
        icon: "trigger",
        onResponseBody: (body, span) => {
            if (body && typeof body === "object" && !Array.isArray(body)) {
                if ("id" in body && typeof body.id === "string") {
                    span.setAttribute("runId", body.id);
                }
            }
        },
        ...requestOptions,
    });
    return handle;
}
async function batchTrigger_internal(name, taskIdentifier, items, options, parsePayload, requestOptions, queue) {
    const apiClient = v3_1.apiClientManager.clientOrThrow();
    const ctx = v3_1.taskContext.ctx;
    const response = await apiClient.batchTriggerV3({
        items: await Promise.all(items.map(async (item, index) => {
            const parsedPayload = parsePayload ? await parsePayload(item.payload) : item.payload;
            const payloadPacket = await (0, v3_1.stringifyIO)(parsedPayload);
            const batchItemIdempotencyKey = await (0, v3_1.makeIdempotencyKey)((0, v3_1.flattenIdempotencyKey)([options?.idempotencyKey, `${index}`]));
            return {
                task: taskIdentifier,
                payload: payloadPacket.data,
                options: {
                    queue: item.options?.queue
                        ? { name: item.options.queue }
                        : queue
                            ? { name: queue }
                            : undefined,
                    concurrencyKey: item.options?.concurrencyKey,
                    test: v3_1.taskContext.ctx?.run.isTest,
                    payloadType: payloadPacket.dataType,
                    delay: item.options?.delay,
                    ttl: item.options?.ttl,
                    tags: item.options?.tags,
                    maxAttempts: item.options?.maxAttempts,
                    metadata: item.options?.metadata,
                    maxDuration: item.options?.maxDuration,
                    idempotencyKey: (await (0, v3_1.makeIdempotencyKey)(item.options?.idempotencyKey)) ?? batchItemIdempotencyKey,
                    idempotencyKeyTTL: item.options?.idempotencyKeyTTL ?? options?.idempotencyKeyTTL,
                    machine: item.options?.machine,
                    priority: item.options?.priority,
                    region: item.options?.region,
                    lockToVersion: item.options?.version ?? (0, v3_1.getEnvVar)("TRIGGER_VERSION"),
                },
            };
        })),
        parentRunId: ctx?.run.id,
    }, {
        spanParentAsLink: true,
        processingStrategy: options?.triggerSequentially ? "sequential" : undefined,
    }, {
        name,
        tracer: tracer_js_1.tracer,
        icon: "trigger",
        onResponseBody(body, span) {
            if (body && typeof body === "object" && !Array.isArray(body)) {
                if ("id" in body && typeof body.id === "string") {
                    span.setAttribute("batchId", body.id);
                }
                if ("runCount" in body && Array.isArray(body.runCount)) {
                    span.setAttribute("runCount", body.runCount);
                }
            }
        },
        ...requestOptions,
    });
    const handle = {
        batchId: response.id,
        runCount: response.runCount,
        publicAccessToken: response.publicAccessToken,
    };
    return handle;
}
async function triggerAndWait_internal(name, id, payload, parsePayload, options, requestOptions) {
    const ctx = v3_1.taskContext.ctx;
    if (!ctx) {
        throw new Error("triggerAndWait can only be used from inside a task.run()");
    }
    const apiClient = v3_1.apiClientManager.clientOrThrow();
    const parsedPayload = parsePayload ? await parsePayload(payload) : payload;
    const payloadPacket = await (0, v3_1.stringifyIO)(parsedPayload);
    return await tracer_js_1.tracer.startActiveSpan(name, async (span) => {
        const response = await apiClient.triggerTask(id, {
            payload: payloadPacket.data,
            options: {
                lockToVersion: v3_1.taskContext.worker?.version, // Lock to current version because we're waiting for it to finish
                queue: options?.queue ? { name: options.queue } : undefined,
                concurrencyKey: options?.concurrencyKey,
                test: v3_1.taskContext.ctx?.run.isTest,
                payloadType: payloadPacket.dataType,
                delay: options?.delay,
                ttl: options?.ttl,
                tags: options?.tags,
                maxAttempts: options?.maxAttempts,
                metadata: options?.metadata,
                maxDuration: options?.maxDuration,
                resumeParentOnCompletion: true,
                parentRunId: ctx.run.id,
                idempotencyKey: await (0, v3_1.makeIdempotencyKey)(options?.idempotencyKey),
                idempotencyKeyTTL: options?.idempotencyKeyTTL,
                machine: options?.machine,
                priority: options?.priority,
                region: options?.region,
            },
        }, {}, requestOptions);
        span.setAttribute("runId", response.id);
        const result = await v3_1.runtime.waitForTask({
            id: response.id,
            ctx,
        });
        return await handleTaskRunExecutionResult(result, id);
    }, {
        kind: api_1.SpanKind.PRODUCER,
        attributes: {
            [v3_1.SemanticInternalAttributes.STYLE_ICON]: "trigger",
            ...(0, v3_1.accessoryAttributes)({
                items: [
                    {
                        text: id,
                        variant: "normal",
                    },
                ],
                style: "codepath",
            }),
        },
    });
}
async function batchTriggerAndWait_internal(name, id, items, parsePayload, options, requestOptions, queue) {
    const ctx = v3_1.taskContext.ctx;
    if (!ctx) {
        throw new Error("batchTriggerAndWait can only be used from inside a task.run()");
    }
    const apiClient = v3_1.apiClientManager.clientOrThrow();
    return await tracer_js_1.tracer.startActiveSpan(name, async (span) => {
        const response = await apiClient.batchTriggerV3({
            items: await Promise.all(items.map(async (item, index) => {
                const parsedPayload = parsePayload ? await parsePayload(item.payload) : item.payload;
                const payloadPacket = await (0, v3_1.stringifyIO)(parsedPayload);
                const batchItemIdempotencyKey = await (0, v3_1.makeIdempotencyKey)((0, v3_1.flattenIdempotencyKey)([options?.idempotencyKey, `${index}`]));
                return {
                    task: id,
                    payload: payloadPacket.data,
                    options: {
                        lockToVersion: v3_1.taskContext.worker?.version,
                        queue: item.options?.queue
                            ? { name: item.options.queue }
                            : queue
                                ? { name: queue }
                                : undefined,
                        concurrencyKey: item.options?.concurrencyKey,
                        test: v3_1.taskContext.ctx?.run.isTest,
                        payloadType: payloadPacket.dataType,
                        delay: item.options?.delay,
                        ttl: item.options?.ttl,
                        tags: item.options?.tags,
                        maxAttempts: item.options?.maxAttempts,
                        metadata: item.options?.metadata,
                        maxDuration: item.options?.maxDuration,
                        idempotencyKey: (await (0, v3_1.makeIdempotencyKey)(item.options?.idempotencyKey)) ??
                            batchItemIdempotencyKey,
                        idempotencyKeyTTL: item.options?.idempotencyKeyTTL ?? options?.idempotencyKeyTTL,
                        machine: item.options?.machine,
                        priority: item.options?.priority,
                        region: item.options?.region,
                    },
                };
            })),
            resumeParentOnCompletion: true,
            parentRunId: ctx.run.id,
        }, {
            processingStrategy: options?.triggerSequentially ? "sequential" : undefined,
        }, requestOptions);
        span.setAttribute("batchId", response.id);
        span.setAttribute("runCount", response.runCount);
        const result = await v3_1.runtime.waitForBatch({
            id: response.id,
            runCount: response.runCount,
            ctx,
        });
        const runs = await handleBatchTaskRunExecutionResult(result.items, id);
        return {
            id: result.id,
            runs,
        };
    }, {
        kind: api_1.SpanKind.PRODUCER,
        attributes: {
            [v3_1.SemanticInternalAttributes.STYLE_ICON]: "trigger",
            ...(0, v3_1.accessoryAttributes)({
                items: [
                    {
                        text: id,
                        variant: "normal",
                    },
                ],
                style: "codepath",
            }),
        },
    });
}
async function handleBatchTaskRunExecutionResult(items, taskIdentifier) {
    const someObjectStoreOutputs = items.some((item) => item.ok && item.outputType === "application/store");
    if (!someObjectStoreOutputs) {
        const results = await Promise.all(items.map(async (item) => {
            return await handleTaskRunExecutionResult(item, taskIdentifier);
        }));
        return results;
    }
    return await tracer_js_1.tracer.startActiveSpan("store.downloadPayloads", async (span) => {
        const results = await Promise.all(items.map(async (item) => {
            return await handleTaskRunExecutionResult(item, taskIdentifier);
        }));
        return results;
    }, {
        kind: api_1.SpanKind.INTERNAL,
        [v3_1.SemanticInternalAttributes.STYLE_ICON]: "cloud-download",
    });
}
async function handleBatchTaskRunExecutionResultV2(items) {
    const someObjectStoreOutputs = items.some((item) => item.ok && item.outputType === "application/store");
    if (!someObjectStoreOutputs) {
        const results = await Promise.all(items.map(async (item) => {
            return await handleTaskRunExecutionResult(item, item.taskIdentifier ?? "unknown");
        }));
        return results;
    }
    return await tracer_js_1.tracer.startActiveSpan("store.downloadPayloads", async (span) => {
        const results = await Promise.all(items.map(async (item) => {
            return await handleTaskRunExecutionResult(item, item.taskIdentifier ?? "unknown");
        }));
        return results;
    }, {
        kind: api_1.SpanKind.INTERNAL,
        [v3_1.SemanticInternalAttributes.STYLE_ICON]: "cloud-download",
    });
}
async function handleTaskRunExecutionResult(execution, taskIdentifier) {
    if (execution.ok) {
        const outputPacket = { data: execution.output, dataType: execution.outputType };
        const importedPacket = await (0, v3_1.conditionallyImportPacket)(outputPacket, tracer_js_1.tracer);
        return {
            ok: true,
            id: execution.id,
            taskIdentifier: (execution.taskIdentifier ?? taskIdentifier),
            output: await (0, v3_1.parsePacket)(importedPacket),
        };
    }
    else {
        return {
            ok: false,
            id: execution.id,
            taskIdentifier: (execution.taskIdentifier ?? taskIdentifier),
            error: (0, v3_1.createErrorTaskError)(execution.error),
        };
    }
}
function registerTaskLifecycleHooks(taskId, params) {
    if (params.init) {
        v3_1.lifecycleHooks.registerTaskInitHook(taskId, {
            fn: params.init,
        });
    }
    if (params.onStart) {
        v3_1.lifecycleHooks.registerTaskStartHook(taskId, {
            fn: params.onStart,
        });
    }
    if (params.onFailure) {
        v3_1.lifecycleHooks.registerTaskFailureHook(taskId, {
            fn: params.onFailure,
        });
    }
    if (params.onSuccess) {
        v3_1.lifecycleHooks.registerTaskSuccessHook(taskId, {
            fn: params.onSuccess,
        });
    }
    if (params.onComplete) {
        v3_1.lifecycleHooks.registerTaskCompleteHook(taskId, {
            fn: params.onComplete,
        });
    }
    if (params.onWait) {
        v3_1.lifecycleHooks.registerTaskWaitHook(taskId, {
            fn: params.onWait,
        });
    }
    if (params.onResume) {
        v3_1.lifecycleHooks.registerTaskResumeHook(taskId, {
            fn: params.onResume,
        });
    }
    if (params.catchError) {
        // We don't need to use an adapter here because catchError is the new version of handleError
        v3_1.lifecycleHooks.registerTaskCatchErrorHook(taskId, {
            fn: params.catchError,
        });
    }
    if (params.handleError) {
        v3_1.lifecycleHooks.registerTaskCatchErrorHook(taskId, {
            fn: params.handleError,
        });
    }
    if (params.middleware) {
        v3_1.lifecycleHooks.registerTaskMiddlewareHook(taskId, {
            fn: params.middleware,
        });
    }
    if (params.cleanup) {
        v3_1.lifecycleHooks.registerTaskCleanupHook(taskId, {
            fn: params.cleanup,
        });
    }
    if (params.onCancel) {
        v3_1.lifecycleHooks.registerTaskCancelHook(taskId, {
            fn: params.onCancel,
        });
    }
}
//# sourceMappingURL=shared.js.map