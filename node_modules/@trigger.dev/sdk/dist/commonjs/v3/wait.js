"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.wait = exports.WaitpointTimeoutError = void 0;
const api_1 = require("@opentelemetry/api");
const v3_1 = require("@trigger.dev/core/v3");
const ioSerialization_1 = require("@trigger.dev/core/v3/utils/ioSerialization");
const tracer_js_1 = require("./tracer.js");
/**
 * This creates a waitpoint token.
 * You can use this to pause a run until you complete the waitpoint (or it times out).
 *
 * @example
 *
 * **Manually completing a token**
 *
 * ```ts
 * const token = await wait.createToken({
 *   idempotencyKey: `approve-document-${documentId}`,
 *   timeout: "24h",
 *   tags: [`document-${documentId}`],
 * });
 *
 * // Later, in a different part of your codebase, you can complete the waitpoint
 * await wait.completeToken(token, {
 *   status: "approved",
 *   comment: "Looks good to me!",
 * });
 * ```
 *
 * @example
 *
 * **Completing a token with a webhook**
 *
 * ```ts
 * const token = await wait.createToken({
 *   timeout: "10m",
 *   tags: ["replicate"],
 * });
 *
 * // Later, in a different part of your codebase, you can complete the waitpoint
 * await replicate.predictions.create({
 *   version: "27b93a2413e7f36cd83da926f3656280b2931564ff050bf9575f1fdf9bcd7478",
 *   input: {
 *     prompt: "A painting of a cat by Andy Warhol",
 *   },
 *   // pass the provided URL to Replicate's webhook, so they can "callback"
 *   webhook: token.url,
 *   webhook_events_filter: ["completed"],
 * });
 *
 * const prediction = await wait.forToken<Prediction>(token).unwrap();
 * ```
 *
 * @param options - The options for the waitpoint token.
 * @param requestOptions - The request options for the waitpoint token.
 * @returns The waitpoint token.
 */
function createToken(options, requestOptions) {
    const apiClient = v3_1.apiClientManager.clientOrThrow();
    const $requestOptions = (0, v3_1.mergeRequestOptions)({
        tracer: tracer_js_1.tracer,
        name: "wait.createToken()",
        icon: "wait-token",
        attributes: {
            idempotencyKey: options?.idempotencyKey,
            idempotencyKeyTTL: options?.idempotencyKeyTTL,
            timeout: options?.timeout
                ? typeof options.timeout === "string"
                    ? options.timeout
                    : options.timeout.toISOString()
                : undefined,
            tags: options?.tags,
        },
        onResponseBody: (body, span) => {
            span.setAttribute("id", body.id);
            span.setAttribute("isCached", body.isCached);
            span.setAttribute("url", body.url);
        },
    }, requestOptions);
    return apiClient.createWaitpointToken(options ?? {}, $requestOptions);
}
/**
 * Lists waitpoint tokens with optional filtering and pagination.
 * You can iterate over all the items in the result using a for-await-of loop (you don't need to think about pagination).
 *
 * @example
 * Basic usage:
 * ```ts
 * // List all tokens
 * for await (const token of wait.listTokens()) {
 *   console.log("Token ID:", token.id);
 * }
 * ```
 *
 * @example
 * With filters:
 * ```ts
 * // List completed tokens from the last 24 hours with specific tags
 * for await (const token of wait.listTokens({
 *   status: "COMPLETED",
 *   period: "24h",
 *   tags: ["important", "approval"],
 *   limit: 50
 * })) {
 *   console.log("Token ID:", token.id);
 * }
 * ```
 *
 * @param params - Optional query parameters for filtering and pagination
 * @param params.status - Filter by token status
 * @param params.idempotencyKey - Filter by idempotency key
 * @param params.tags - Filter by tags
 * @param params.period - Filter by time period (e.g. "24h", "7d")
 * @param params.from - Filter by start date
 * @param params.to - Filter by end date
 * @param params.limit - Number of items per page
 * @param params.after - Cursor for next page
 * @param params.before - Cursor for previous page
 * @param requestOptions - Additional API request options
 * @returns Waitpoint tokens that can easily be iterated over using a for-await-of loop
 */
function listTokens(params, requestOptions) {
    const apiClient = v3_1.apiClientManager.clientOrThrow();
    const $requestOptions = (0, v3_1.mergeRequestOptions)({
        tracer: tracer_js_1.tracer,
        name: "wait.listTokens()",
        icon: "wait-token",
        attributes: {
            ...(0, v3_1.flattenAttributes)(params),
        },
    }, requestOptions);
    return apiClient.listWaitpointTokens(params, $requestOptions);
}
/**
 * Retrieves a waitpoint token by its ID.
 *
 * @example
 * ```ts
 * const token = await wait.retrieveToken("waitpoint_12345678910");
 * console.log("Token status:", token.status);
 * console.log("Token tags:", token.tags);
 * ```
 *
 * @param token - The token to retrieve.
 * This can be a string token ID or an object with an `id` property.
 * @param requestOptions - Optional API request options.
 * @returns The waitpoint token details, including the output or error if the waitpoint is completed or timed out.
 */
async function retrieveToken(token, requestOptions) {
    const apiClient = v3_1.apiClientManager.clientOrThrow();
    const $tokenId = typeof token === "string" ? token : token.id;
    const $requestOptions = (0, v3_1.mergeRequestOptions)({
        tracer: tracer_js_1.tracer,
        name: "wait.retrieveToken()",
        icon: "wait-token",
        attributes: {
            id: $tokenId,
            ...(0, v3_1.accessoryAttributes)({
                items: [
                    {
                        text: $tokenId,
                        variant: "normal",
                    },
                ],
                style: "codepath",
            }),
        },
        onResponseBody: (body, span) => {
            span.setAttribute("id", body.id);
            span.setAttribute("url", body.url);
            span.setAttribute("status", body.status);
            if (body.completedAt) {
                span.setAttribute("completedAt", body.completedAt.toISOString());
            }
            if (body.timeoutAt) {
                span.setAttribute("timeoutAt", body.timeoutAt.toISOString());
            }
            if (body.idempotencyKey) {
                span.setAttribute("idempotencyKey", body.idempotencyKey);
            }
            if (body.idempotencyKeyExpiresAt) {
                span.setAttribute("idempotencyKeyExpiresAt", body.idempotencyKeyExpiresAt.toISOString());
            }
            span.setAttribute("tags", body.tags);
            span.setAttribute("createdAt", body.createdAt.toISOString());
        },
    }, requestOptions);
    const result = await apiClient.retrieveWaitpointToken($tokenId, $requestOptions);
    const data = result.output
        ? await (0, ioSerialization_1.conditionallyImportAndParsePacket)({ data: result.output, dataType: result.outputType ?? "application/json" }, apiClient)
        : undefined;
    let error = undefined;
    let output = undefined;
    if (result.outputIsError) {
        error = new WaitpointTimeoutError(data.message);
    }
    else {
        output = data;
    }
    return {
        id: result.id,
        url: result.url,
        status: result.status,
        completedAt: result.completedAt,
        timeoutAt: result.timeoutAt,
        idempotencyKey: result.idempotencyKey,
        idempotencyKeyExpiresAt: result.idempotencyKeyExpiresAt,
        tags: result.tags,
        createdAt: result.createdAt,
        output,
        error,
    };
}
/**
 * This completes a waitpoint token.
 * You can use this to complete a waitpoint token that you created earlier.
 *
 * @example
 *
 * ```ts
 * await wait.completeToken(token, {
 *   status: "approved",
 *   comment: "Looks good to me!",
 * });
 * ```
 *
 * @param token - The token to complete.
 * @param data - The data to complete the waitpoint with.
 * @param requestOptions - The request options for the waitpoint token.
 * @returns The waitpoint token.
 */
async function completeToken(
/**
 * The token to complete.
 * This can be a string token ID or an object with an `id` property.
 */
token, 
/**
 * The data to complete the waitpoint with.
 * This will be returned when you wait for the token.
 */
data, requestOptions) {
    const apiClient = v3_1.apiClientManager.clientOrThrow();
    const tokenId = typeof token === "string" ? token : token.id;
    const $requestOptions = (0, v3_1.mergeRequestOptions)({
        tracer: tracer_js_1.tracer,
        name: "wait.completeToken()",
        icon: "wait-token",
        attributes: {
            id: tokenId,
        },
        onResponseBody: (body, span) => {
            span.setAttribute("success", body.success);
        },
    }, requestOptions);
    return apiClient.completeWaitpointToken(tokenId, { data }, $requestOptions);
}
class WaitpointTimeoutError extends Error {
    constructor(message) {
        super(message);
        this.name = "WaitpointTimeoutError";
    }
}
exports.WaitpointTimeoutError = WaitpointTimeoutError;
const DURATION_WAIT_CHARGE_THRESHOLD_MS = 5000;
function printWaitBelowThreshold() {
    console.warn(`Waits of ${DURATION_WAIT_CHARGE_THRESHOLD_MS / 1000}s or less count towards compute usage.`);
}
class ManualWaitpointPromise extends Promise {
    constructor(executor) {
        super(executor);
    }
    unwrap() {
        return this.then((result) => {
            if (result.ok) {
                return result.output;
            }
            else {
                throw new WaitpointTimeoutError(result.error.message);
            }
        });
    }
}
exports.wait = {
    for: async (options) => {
        const ctx = v3_1.taskContext.ctx;
        if (!ctx) {
            throw new Error("wait.forToken can only be used from inside a task.run()");
        }
        const apiClient = v3_1.apiClientManager.clientOrThrow();
        const start = Date.now();
        const durationInMs = calculateDurationInMs(options);
        if (durationInMs <= DURATION_WAIT_CHARGE_THRESHOLD_MS) {
            return tracer_js_1.tracer.startActiveSpan(`wait.for()`, async (span) => {
                if (durationInMs <= 0) {
                    return;
                }
                printWaitBelowThreshold();
                await new Promise((resolve) => setTimeout(resolve, durationInMs));
            }, {
                attributes: {
                    [v3_1.SemanticInternalAttributes.STYLE_ICON]: "wait",
                    ...(0, v3_1.accessoryAttributes)({
                        items: [
                            {
                                text: nameForWaitOptions(options),
                                variant: "normal",
                            },
                        ],
                        style: "codepath",
                    }),
                },
            });
        }
        const date = new Date(start + durationInMs);
        const result = await apiClient.waitForDuration(ctx.run.id, {
            date: date,
            idempotencyKey: options.idempotencyKey,
            idempotencyKeyTTL: options.idempotencyKeyTTL,
        });
        return tracer_js_1.tracer.startActiveSpan(`wait.for()`, async (span) => {
            await v3_1.runtime.waitUntil(result.waitpoint.id, date);
        }, {
            attributes: {
                [v3_1.SemanticInternalAttributes.STYLE_ICON]: "wait",
                [v3_1.SemanticInternalAttributes.ENTITY_TYPE]: "waitpoint",
                [v3_1.SemanticInternalAttributes.ENTITY_ID]: result.waitpoint.id,
                ...(0, v3_1.accessoryAttributes)({
                    items: [
                        {
                            text: nameForWaitOptions(options),
                            variant: "normal",
                        },
                    ],
                    style: "codepath",
                }),
            },
        });
    },
    until: async (options) => {
        const ctx = v3_1.taskContext.ctx;
        if (!ctx) {
            throw new Error("wait.forToken can only be used from inside a task.run()");
        }
        // Calculate duration in ms
        const durationInMs = options.date.getTime() - Date.now();
        if (durationInMs <= DURATION_WAIT_CHARGE_THRESHOLD_MS) {
            return tracer_js_1.tracer.startActiveSpan(`wait.for()`, async (span) => {
                if (durationInMs === 0) {
                    return;
                }
                if (durationInMs < 0) {
                    if (options.throwIfInThePast) {
                        throw new Error("Date is in the past");
                    }
                    return;
                }
                printWaitBelowThreshold();
                await new Promise((resolve) => setTimeout(resolve, durationInMs));
            }, {
                attributes: {
                    [v3_1.SemanticInternalAttributes.STYLE_ICON]: "wait",
                    ...(0, v3_1.accessoryAttributes)({
                        items: [
                            {
                                text: options.date.toISOString(),
                                variant: "normal",
                            },
                        ],
                        style: "codepath",
                    }),
                },
            });
        }
        const apiClient = v3_1.apiClientManager.clientOrThrow();
        const result = await apiClient.waitForDuration(ctx.run.id, {
            date: options.date,
            idempotencyKey: options.idempotencyKey,
            idempotencyKeyTTL: options.idempotencyKeyTTL,
        });
        return tracer_js_1.tracer.startActiveSpan(`wait.until()`, async (span) => {
            if (options.throwIfInThePast && options.date < new Date()) {
                throw new Error("Date is in the past");
            }
            await v3_1.runtime.waitUntil(result.waitpoint.id, options.date);
        }, {
            attributes: {
                [v3_1.SemanticInternalAttributes.STYLE_ICON]: "wait",
                [v3_1.SemanticInternalAttributes.ENTITY_TYPE]: "waitpoint",
                [v3_1.SemanticInternalAttributes.ENTITY_ID]: result.waitpoint.id,
                ...(0, v3_1.accessoryAttributes)({
                    items: [
                        {
                            text: options.date.toISOString(),
                            variant: "normal",
                        },
                    ],
                    style: "codepath",
                }),
            },
        });
    },
    createToken,
    listTokens,
    completeToken,
    retrieveToken,
    /**
     * This waits for a waitpoint token to be completed.
     * It can only be used inside a task.run() block.
     *
     * @example
     *
     * ```ts
     * const result = await wait.forToken<typeof ApprovalData>(token);
     * if (!result.ok) {
     *   // The waitpoint timed out
     *   throw result.error;
     * }
     *
     * // This will be the type ApprovalData
     * const approval = result.output;
     * ```
     *
     * @param token - The token to wait for.
     * @param options - The options for the waitpoint token.
     * @returns A promise that resolves to the result of the waitpoint. You can use `.unwrap()` to get the result and an error will throw.
     */
    forToken: (
    /**
     * The token to wait for.
     * This can be a string token ID or an object with an `id` property.
     */
    token) => {
        return new ManualWaitpointPromise(async (resolve, reject) => {
            try {
                const ctx = v3_1.taskContext.ctx;
                if (!ctx) {
                    throw new Error("wait.forToken can only be used from inside a task.run()");
                }
                const apiClient = v3_1.apiClientManager.clientOrThrow();
                const tokenId = typeof token === "string" ? token : token.id;
                const result = await tracer_js_1.tracer.startActiveSpan(`wait.forToken()`, async (span) => {
                    const response = await apiClient.waitForWaitpointToken({
                        runFriendlyId: ctx.run.id,
                        waitpointFriendlyId: tokenId,
                    });
                    if (!response.success) {
                        throw new Error(`Failed to wait for wait token ${tokenId}`);
                    }
                    const result = await v3_1.runtime.waitUntil(tokenId);
                    const data = result.output
                        ? await (0, ioSerialization_1.conditionallyImportAndParsePacket)({ data: result.output, dataType: result.outputType ?? "application/json" }, apiClient)
                        : undefined;
                    if (result.ok) {
                        return {
                            ok: result.ok,
                            output: data,
                        };
                    }
                    else {
                        const error = new WaitpointTimeoutError(data.message);
                        span.recordException(error);
                        span.setStatus({
                            code: api_1.SpanStatusCode.ERROR,
                        });
                        return {
                            ok: result.ok,
                            error,
                        };
                    }
                }, {
                    attributes: {
                        [v3_1.SemanticInternalAttributes.STYLE_ICON]: "wait",
                        [v3_1.SemanticInternalAttributes.ENTITY_TYPE]: "waitpoint",
                        [v3_1.SemanticInternalAttributes.ENTITY_ID]: tokenId,
                        id: tokenId,
                        ...(0, v3_1.accessoryAttributes)({
                            items: [
                                {
                                    text: tokenId,
                                    variant: "normal",
                                },
                            ],
                            style: "codepath",
                        }),
                    },
                });
                resolve(result);
            }
            catch (error) {
                reject(error);
            }
        });
    },
};
function nameForWaitOptions(options) {
    if ("seconds" in options) {
        return options.seconds === 1 ? `1 second` : `${options.seconds} seconds`;
    }
    if ("minutes" in options) {
        return options.minutes === 1 ? `1 minute` : `${options.minutes} minutes`;
    }
    if ("hours" in options) {
        return options.hours === 1 ? `1 hour` : `${options.hours} hours`;
    }
    if ("days" in options) {
        return options.days === 1 ? `1 day` : `${options.days} days`;
    }
    if ("weeks" in options) {
        return options.weeks === 1 ? `1 week` : `${options.weeks} weeks`;
    }
    if ("months" in options) {
        return options.months === 1 ? `1 month` : `${options.months} months`;
    }
    if ("years" in options) {
        return options.years === 1 ? `1 year` : `${options.years} years`;
    }
    return "NaN";
}
function calculateDurationInMs(options) {
    if ("seconds" in options) {
        return options.seconds * 1000;
    }
    if ("minutes" in options) {
        return options.minutes * 1000 * 60;
    }
    if ("hours" in options) {
        return options.hours * 1000 * 60 * 60;
    }
    if ("days" in options) {
        return options.days * 1000 * 60 * 60 * 24;
    }
    if ("weeks" in options) {
        return options.weeks * 1000 * 60 * 60 * 24 * 7;
    }
    if ("months" in options) {
        return options.months * 1000 * 60 * 60 * 24 * 30;
    }
    if ("years" in options) {
        return options.years * 1000 * 60 * 60 * 24 * 365;
    }
    throw new Error("Invalid options");
}
//# sourceMappingURL=wait.js.map