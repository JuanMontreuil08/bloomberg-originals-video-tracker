import { ApiPromise, ApiRequestOptions, CreateWaitpointTokenRequestBody, CreateWaitpointTokenResponse, CursorPagePromise, ListWaitpointTokensQueryParams, WaitpointListTokenItem, WaitpointTokenStatus, WaitpointTokenTypedResult } from "@trigger.dev/core/v3";
/**
 * This creates a waitpoint token.
 * You can use this to pause a run until you complete the waitpoint (or it times out).
 *
 * @example
 *
 * **Manually completing a token**
 *
 * ```ts
 * const token = await wait.createToken({
 *   idempotencyKey: `approve-document-${documentId}`,
 *   timeout: "24h",
 *   tags: [`document-${documentId}`],
 * });
 *
 * // Later, in a different part of your codebase, you can complete the waitpoint
 * await wait.completeToken(token, {
 *   status: "approved",
 *   comment: "Looks good to me!",
 * });
 * ```
 *
 * @example
 *
 * **Completing a token with a webhook**
 *
 * ```ts
 * const token = await wait.createToken({
 *   timeout: "10m",
 *   tags: ["replicate"],
 * });
 *
 * // Later, in a different part of your codebase, you can complete the waitpoint
 * await replicate.predictions.create({
 *   version: "27b93a2413e7f36cd83da926f3656280b2931564ff050bf9575f1fdf9bcd7478",
 *   input: {
 *     prompt: "A painting of a cat by Andy Warhol",
 *   },
 *   // pass the provided URL to Replicate's webhook, so they can "callback"
 *   webhook: token.url,
 *   webhook_events_filter: ["completed"],
 * });
 *
 * const prediction = await wait.forToken<Prediction>(token).unwrap();
 * ```
 *
 * @param options - The options for the waitpoint token.
 * @param requestOptions - The request options for the waitpoint token.
 * @returns The waitpoint token.
 */
declare function createToken(options?: CreateWaitpointTokenRequestBody, requestOptions?: ApiRequestOptions): ApiPromise<CreateWaitpointTokenResponse>;
/**
 * Lists waitpoint tokens with optional filtering and pagination.
 * You can iterate over all the items in the result using a for-await-of loop (you don't need to think about pagination).
 *
 * @example
 * Basic usage:
 * ```ts
 * // List all tokens
 * for await (const token of wait.listTokens()) {
 *   console.log("Token ID:", token.id);
 * }
 * ```
 *
 * @example
 * With filters:
 * ```ts
 * // List completed tokens from the last 24 hours with specific tags
 * for await (const token of wait.listTokens({
 *   status: "COMPLETED",
 *   period: "24h",
 *   tags: ["important", "approval"],
 *   limit: 50
 * })) {
 *   console.log("Token ID:", token.id);
 * }
 * ```
 *
 * @param params - Optional query parameters for filtering and pagination
 * @param params.status - Filter by token status
 * @param params.idempotencyKey - Filter by idempotency key
 * @param params.tags - Filter by tags
 * @param params.period - Filter by time period (e.g. "24h", "7d")
 * @param params.from - Filter by start date
 * @param params.to - Filter by end date
 * @param params.limit - Number of items per page
 * @param params.after - Cursor for next page
 * @param params.before - Cursor for previous page
 * @param requestOptions - Additional API request options
 * @returns Waitpoint tokens that can easily be iterated over using a for-await-of loop
 */
declare function listTokens(params?: ListWaitpointTokensQueryParams, requestOptions?: ApiRequestOptions): CursorPagePromise<typeof WaitpointListTokenItem>;
/**
 * A waitpoint token that has been retrieved.
 *
 * If the status is `WAITING`, this means the waitpoint is still pending.
 * For `COMPLETED` the `output` will be the data you passed in when completing the waitpoint.
 * For `TIMED_OUT` there will be an `error`.
 */
export type WaitpointRetrievedToken<T> = {
    id: string;
    /** A URL that you can make a POST request to in order to complete the waitpoint. */
    url: string;
    status: WaitpointTokenStatus;
    completedAt?: Date;
    timeoutAt?: Date;
    idempotencyKey?: string;
    idempotencyKeyExpiresAt?: Date;
    tags: string[];
    createdAt: Date;
    output?: T;
    error?: Error;
};
/**
 * Retrieves a waitpoint token by its ID.
 *
 * @example
 * ```ts
 * const token = await wait.retrieveToken("waitpoint_12345678910");
 * console.log("Token status:", token.status);
 * console.log("Token tags:", token.tags);
 * ```
 *
 * @param token - The token to retrieve.
 * This can be a string token ID or an object with an `id` property.
 * @param requestOptions - Optional API request options.
 * @returns The waitpoint token details, including the output or error if the waitpoint is completed or timed out.
 */
declare function retrieveToken<T>(token: string | {
    id: string;
}, requestOptions?: ApiRequestOptions): Promise<WaitpointRetrievedToken<T>>;
/**
 * This completes a waitpoint token.
 * You can use this to complete a waitpoint token that you created earlier.
 *
 * @example
 *
 * ```ts
 * await wait.completeToken(token, {
 *   status: "approved",
 *   comment: "Looks good to me!",
 * });
 * ```
 *
 * @param token - The token to complete.
 * @param data - The data to complete the waitpoint with.
 * @param requestOptions - The request options for the waitpoint token.
 * @returns The waitpoint token.
 */
declare function completeToken<T>(
/**
 * The token to complete.
 * This can be a string token ID or an object with an `id` property.
 */
token: string | {
    id: string;
}, 
/**
 * The data to complete the waitpoint with.
 * This will be returned when you wait for the token.
 */
data: T, requestOptions?: ApiRequestOptions): Promise<{
    success: true;
}>;
export type CommonWaitOptions = {
    /**
     * An optional idempotency key for the waitpoint.
     * If you use the same key twice (and the key hasn't expired), you will get the original waitpoint back.
     *
     * Note: This waitpoint may already be complete, in which case when you wait for it, it will immediately continue.
     */
    idempotencyKey?: string;
    /**
     * When set, this means the passed in idempotency key will expire after this time.
     * This means after that time if you pass the same idempotency key again, you will get a new waitpoint.
     */
    idempotencyKeyTTL?: string;
};
export type WaitForOptions = WaitPeriod & CommonWaitOptions;
type WaitPeriod = {
    seconds: number;
} | {
    minutes: number;
} | {
    hours: number;
} | {
    days: number;
} | {
    weeks: number;
} | {
    months: number;
} | {
    years: number;
};
export declare class WaitpointTimeoutError extends Error {
    constructor(message: string);
}
declare class ManualWaitpointPromise<TOutput> extends Promise<WaitpointTokenTypedResult<TOutput>> {
    constructor(executor: (resolve: (value: WaitpointTokenTypedResult<TOutput> | PromiseLike<WaitpointTokenTypedResult<TOutput>>) => void, reject: (reason?: any) => void) => void);
    unwrap(): Promise<TOutput>;
}
export declare const wait: {
    for: (options: WaitForOptions) => Promise<void>;
    until: (options: {
        date: Date;
        throwIfInThePast?: boolean;
    } & CommonWaitOptions) => Promise<void>;
    createToken: typeof createToken;
    listTokens: typeof listTokens;
    completeToken: typeof completeToken;
    retrieveToken: typeof retrieveToken;
    /**
     * This waits for a waitpoint token to be completed.
     * It can only be used inside a task.run() block.
     *
     * @example
     *
     * ```ts
     * const result = await wait.forToken<typeof ApprovalData>(token);
     * if (!result.ok) {
     *   // The waitpoint timed out
     *   throw result.error;
     * }
     *
     * // This will be the type ApprovalData
     * const approval = result.output;
     * ```
     *
     * @param token - The token to wait for.
     * @param options - The options for the waitpoint token.
     * @returns A promise that resolves to the result of the waitpoint. You can use `.unwrap()` to get the result and an error will throw.
     */
    forToken: <T>(token: string | {
        id: string;
    }) => ManualWaitpointPromise<T>;
};
export {};
